{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Bezier = void 0;\n\nvar Bezier = function () {\n  var _f = function _f(mX1, mY1, mX2, mY2) {\n    var NEWTON_ITERATIONS = 4;\n    var NEWTON_MIN_SLOPE = 0.001;\n    var SUBDIVISION_PRECISION = 0.0000001;\n    var SUBDIVISION_MAX_ITERATIONS = 10;\n    var kSplineTableSize = 11;\n    var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\n    var A = function () {\n      var _f = function _f(aA1, aA2) {\n        return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n      };\n\n      _f._closure = {};\n      _f.asString = \"function A(aA1,aA2){return 1.0-3.0*aA2+3.0*aA1;}\";\n      _f.__workletHash = 7696928702327;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var B = function () {\n      var _f = function _f(aA1, aA2) {\n        return 3.0 * aA2 - 6.0 * aA1;\n      };\n\n      _f._closure = {};\n      _f.asString = \"function B(aA1,aA2){return 3.0*aA2-6.0*aA1;}\";\n      _f.__workletHash = 3169786778773;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var C = function () {\n      var _f = function _f(aA1) {\n        return 3.0 * aA1;\n      };\n\n      _f._closure = {};\n      _f.asString = \"function C(aA1){return 3.0*aA1;}\";\n      _f.__workletHash = 6399610653367;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var calcBezier = function () {\n      var _f = function _f(aT, aA1, aA2) {\n        return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n      };\n\n      _f._closure = {\n        A: A,\n        B: B,\n        C: C\n      };\n      _f.asString = \"function calcBezier(aT,aA1,aA2){const{A,B,C}=jsThis._closure;{return((A(aA1,aA2)*aT+B(aA1,aA2))*aT+C(aA1))*aT;}}\";\n      _f.__workletHash = 3153137150968;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var getSlope = function () {\n      var _f = function _f(aT, aA1, aA2) {\n        return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n      };\n\n      _f._closure = {\n        A: A,\n        B: B,\n        C: C\n      };\n      _f.asString = \"function getSlope(aT,aA1,aA2){const{A,B,C}=jsThis._closure;{return 3.0*A(aA1,aA2)*aT*aT+2.0*B(aA1,aA2)*aT+C(aA1);}}\";\n      _f.__workletHash = 17050227570308;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var binarySubdivide = function () {\n      var _f = function _f(aX, aA, aB, mX1, mX2) {\n        var currentX;\n        var currentT;\n        var i = 0;\n\n        do {\n          currentT = aA + (aB - aA) / 2.0;\n          currentX = calcBezier(currentT, mX1, mX2) - aX;\n\n          if (currentX > 0.0) {\n            aB = currentT;\n          } else {\n            aA = currentT;\n          }\n        } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n\n        return currentT;\n      };\n\n      _f._closure = {\n        SUBDIVISION_PRECISION: SUBDIVISION_PRECISION,\n        SUBDIVISION_MAX_ITERATIONS: SUBDIVISION_MAX_ITERATIONS,\n        calcBezier: calcBezier\n      };\n      _f.asString = \"function binarySubdivide(aX,aA,aB,mX1,mX2){const{SUBDIVISION_PRECISION,SUBDIVISION_MAX_ITERATIONS,calcBezier}=jsThis._closure;{var currentX;var currentT;var i=0;do{currentT=aA+(aB-aA)/2.0;currentX=calcBezier(currentT,mX1,mX2)-aX;if(currentX>0.0){aB=currentT;}else{aA=currentT;}}while(Math.abs(currentX)>SUBDIVISION_PRECISION&&++i<SUBDIVISION_MAX_ITERATIONS);return currentT;}}\";\n      _f.__workletHash = 8216390185547;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var newtonRaphsonIterate = function () {\n      var _f = function _f(aX, aGuessT, mX1, mX2) {\n        for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n          var currentSlope = getSlope(aGuessT, mX1, mX2);\n\n          if (currentSlope === 0.0) {\n            return aGuessT;\n          }\n\n          var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n          aGuessT -= currentX / currentSlope;\n        }\n\n        return aGuessT;\n      };\n\n      _f._closure = {\n        NEWTON_ITERATIONS: NEWTON_ITERATIONS,\n        getSlope: getSlope,\n        calcBezier: calcBezier\n      };\n      _f.asString = \"function newtonRaphsonIterate(aX,aGuessT,mX1,mX2){const{NEWTON_ITERATIONS,getSlope,calcBezier}=jsThis._closure;{for(var i=0;i<NEWTON_ITERATIONS;++i){var currentSlope=getSlope(aGuessT,mX1,mX2);if(currentSlope===0.0){return aGuessT;}var currentX=calcBezier(aGuessT,mX1,mX2)-aX;aGuessT-=currentX/currentSlope;}return aGuessT;}}\";\n      _f.__workletHash = 5901993849860;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    var LinearEasing = function () {\n      var _f = function _f(x) {\n        return x;\n      };\n\n      _f._closure = {};\n      _f.asString = \"function LinearEasing(x){return x;}\";\n      _f.__workletHash = 3962143445177;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n      throw new Error('bezier x values must be in [0, 1] range');\n    }\n\n    if (mX1 === mY1 && mX2 === mY2) {\n      return LinearEasing;\n    }\n\n    var sampleValues = new Array(kSplineTableSize);\n\n    for (var i = 0; i < kSplineTableSize; ++i) {\n      sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n\n    var getTForX = function () {\n      var _f = function _f(aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n          intervalStart += kSampleStepSize;\n        }\n\n        --currentSample;\n        var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n\n        if (initialSlope >= NEWTON_MIN_SLOPE) {\n          return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        } else if (initialSlope === 0.0) {\n          return guessForT;\n        } else {\n          return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n      };\n\n      _f._closure = {\n        kSplineTableSize: kSplineTableSize,\n        sampleValues: sampleValues,\n        kSampleStepSize: kSampleStepSize,\n        getSlope: getSlope,\n        mX1: mX1,\n        mX2: mX2,\n        NEWTON_MIN_SLOPE: NEWTON_MIN_SLOPE,\n        newtonRaphsonIterate: newtonRaphsonIterate,\n        binarySubdivide: binarySubdivide\n      };\n      _f.asString = \"function getTForX(aX){const{kSplineTableSize,sampleValues,kSampleStepSize,getSlope,mX1,mX2,NEWTON_MIN_SLOPE,newtonRaphsonIterate,binarySubdivide}=jsThis._closure;{var intervalStart=0.0;var currentSample=1;var lastSample=kSplineTableSize-1;for(;currentSample!==lastSample&&sampleValues[currentSample]<=aX;++currentSample){intervalStart+=kSampleStepSize;}--currentSample;var dist=(aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample]);var guessForT=intervalStart+dist*kSampleStepSize;var initialSlope=getSlope(guessForT,mX1,mX2);if(initialSlope>=NEWTON_MIN_SLOPE){return newtonRaphsonIterate(aX,guessForT,mX1,mX2);}else if(initialSlope===0.0){return guessForT;}else{return binarySubdivide(aX,intervalStart,intervalStart+kSampleStepSize,mX1,mX2);}}}\";\n      _f.__workletHash = 10148290284160;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n\n    return function () {\n      var _f = function _f(x) {\n        if (mX1 === mY1 && mX2 === mY2) {\n          return x;\n        }\n\n        if (x === 0) {\n          return 0;\n        }\n\n        if (x === 1) {\n          return 1;\n        }\n\n        return calcBezier(getTForX(x), mY1, mY2);\n      };\n\n      _f._closure = {\n        mX1: mX1,\n        mY1: mY1,\n        mX2: mX2,\n        mY2: mY2,\n        calcBezier: calcBezier,\n        getTForX: getTForX\n      };\n      _f.asString = \"function BezierEasing(x){const{mX1,mY1,mX2,mY2,calcBezier,getTForX}=jsThis._closure;{if(mX1===mY1&&mX2===mY2){return x;}if(x===0){return 0;}if(x===1){return 1;}return calcBezier(getTForX(x),mY1,mY2);}}\";\n      _f.__workletHash = 8676971518933;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }();\n  };\n\n  _f._closure = {};\n  _f.asString = \"function Bezier(mX1,mY1,mX2,mY2){var NEWTON_ITERATIONS=4;var NEWTON_MIN_SLOPE=0.001;var SUBDIVISION_PRECISION=0.0000001;var SUBDIVISION_MAX_ITERATIONS=10;var kSplineTableSize=11;var kSampleStepSize=1.0/(kSplineTableSize-1.0);var A=function(){var _f=function _f(aA1,aA2){return 1.0-3.0*aA2+3.0*aA1;};_f._closure={};_f.asString=\\\"function A(aA1,aA2){return 1.0-3.0*aA2+3.0*aA1;}\\\";_f.__workletHash=7696928702327;global.__reanimatedWorkletInit(_f);return _f;}();var B=function(){var _f=function _f(aA1,aA2){return 3.0*aA2-6.0*aA1;};_f._closure={};_f.asString=\\\"function B(aA1,aA2){return 3.0*aA2-6.0*aA1;}\\\";_f.__workletHash=3169786778773;global.__reanimatedWorkletInit(_f);return _f;}();var C=function(){var _f=function _f(aA1){return 3.0*aA1;};_f._closure={};_f.asString=\\\"function C(aA1){return 3.0*aA1;}\\\";_f.__workletHash=6399610653367;global.__reanimatedWorkletInit(_f);return _f;}();var calcBezier=function(){var _f=function _f(aT,aA1,aA2){return((A(aA1,aA2)*aT+B(aA1,aA2))*aT+C(aA1))*aT;};_f._closure={A:A,B:B,C:C};_f.asString=\\\"function calcBezier(aT,aA1,aA2){const{A,B,C}=jsThis._closure;{return((A(aA1,aA2)*aT+B(aA1,aA2))*aT+C(aA1))*aT;}}\\\";_f.__workletHash=3153137150968;global.__reanimatedWorkletInit(_f);return _f;}();var getSlope=function(){var _f=function _f(aT,aA1,aA2){return 3.0*A(aA1,aA2)*aT*aT+2.0*B(aA1,aA2)*aT+C(aA1);};_f._closure={A:A,B:B,C:C};_f.asString=\\\"function getSlope(aT,aA1,aA2){const{A,B,C}=jsThis._closure;{return 3.0*A(aA1,aA2)*aT*aT+2.0*B(aA1,aA2)*aT+C(aA1);}}\\\";_f.__workletHash=17050227570308;global.__reanimatedWorkletInit(_f);return _f;}();var binarySubdivide=function(){var _f=function _f(aX,aA,aB,mX1,mX2){var currentX;var currentT;var i=0;do{currentT=aA+(aB-aA)/2.0;currentX=calcBezier(currentT,mX1,mX2)-aX;if(currentX>0.0){aB=currentT;}else{aA=currentT;}}while(Math.abs(currentX)>SUBDIVISION_PRECISION&&++i<SUBDIVISION_MAX_ITERATIONS);return currentT;};_f._closure={SUBDIVISION_PRECISION:SUBDIVISION_PRECISION,SUBDIVISION_MAX_ITERATIONS:SUBDIVISION_MAX_ITERATIONS,calcBezier:calcBezier};_f.asString=\\\"function binarySubdivide(aX,aA,aB,mX1,mX2){const{SUBDIVISION_PRECISION,SUBDIVISION_MAX_ITERATIONS,calcBezier}=jsThis._closure;{var currentX;var currentT;var i=0;do{currentT=aA+(aB-aA)/2.0;currentX=calcBezier(currentT,mX1,mX2)-aX;if(currentX>0.0){aB=currentT;}else{aA=currentT;}}while(Math.abs(currentX)>SUBDIVISION_PRECISION&&++i<SUBDIVISION_MAX_ITERATIONS);return currentT;}}\\\";_f.__workletHash=8216390185547;global.__reanimatedWorkletInit(_f);return _f;}();var newtonRaphsonIterate=function(){var _f=function _f(aX,aGuessT,mX1,mX2){for(var i=0;i<NEWTON_ITERATIONS;++i){var currentSlope=getSlope(aGuessT,mX1,mX2);if(currentSlope===0.0){return aGuessT;}var currentX=calcBezier(aGuessT,mX1,mX2)-aX;aGuessT-=currentX/currentSlope;}return aGuessT;};_f._closure={NEWTON_ITERATIONS:NEWTON_ITERATIONS,getSlope:getSlope,calcBezier:calcBezier};_f.asString=\\\"function newtonRaphsonIterate(aX,aGuessT,mX1,mX2){const{NEWTON_ITERATIONS,getSlope,calcBezier}=jsThis._closure;{for(var i=0;i<NEWTON_ITERATIONS;++i){var currentSlope=getSlope(aGuessT,mX1,mX2);if(currentSlope===0.0){return aGuessT;}var currentX=calcBezier(aGuessT,mX1,mX2)-aX;aGuessT-=currentX/currentSlope;}return aGuessT;}}\\\";_f.__workletHash=5901993849860;global.__reanimatedWorkletInit(_f);return _f;}();var LinearEasing=function(){var _f=function _f(x){return x;};_f._closure={};_f.asString=\\\"function LinearEasing(x){return x;}\\\";_f.__workletHash=3962143445177;global.__reanimatedWorkletInit(_f);return _f;}();if(!(mX1>=0&&mX1<=1&&mX2>=0&&mX2<=1)){throw new Error('bezier x values must be in [0, 1] range');}if(mX1===mY1&&mX2===mY2){return LinearEasing;}var sampleValues=new Array(kSplineTableSize);for(var i=0;i<kSplineTableSize;++i){sampleValues[i]=calcBezier(i*kSampleStepSize,mX1,mX2);}var getTForX=function(){var _f=function _f(aX){var intervalStart=0.0;var currentSample=1;var lastSample=kSplineTableSize-1;for(;currentSample!==lastSample&&sampleValues[currentSample]<=aX;++currentSample){intervalStart+=kSampleStepSize;}--currentSample;var dist=(aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample]);var guessForT=intervalStart+dist*kSampleStepSize;var initialSlope=getSlope(guessForT,mX1,mX2);if(initialSlope>=NEWTON_MIN_SLOPE){return newtonRaphsonIterate(aX,guessForT,mX1,mX2);}else if(initialSlope===0.0){return guessForT;}else{return binarySubdivide(aX,intervalStart,intervalStart+kSampleStepSize,mX1,mX2);}};_f._closure={kSplineTableSize:kSplineTableSize,sampleValues:sampleValues,kSampleStepSize:kSampleStepSize,getSlope:getSlope,mX1:mX1,mX2:mX2,NEWTON_MIN_SLOPE:NEWTON_MIN_SLOPE,newtonRaphsonIterate:newtonRaphsonIterate,binarySubdivide:binarySubdivide};_f.asString=\\\"function getTForX(aX){const{kSplineTableSize,sampleValues,kSampleStepSize,getSlope,mX1,mX2,NEWTON_MIN_SLOPE,newtonRaphsonIterate,binarySubdivide}=jsThis._closure;{var intervalStart=0.0;var currentSample=1;var lastSample=kSplineTableSize-1;for(;currentSample!==lastSample&&sampleValues[currentSample]<=aX;++currentSample){intervalStart+=kSampleStepSize;}--currentSample;var dist=(aX-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample]);var guessForT=intervalStart+dist*kSampleStepSize;var initialSlope=getSlope(guessForT,mX1,mX2);if(initialSlope>=NEWTON_MIN_SLOPE){return newtonRaphsonIterate(aX,guessForT,mX1,mX2);}else if(initialSlope===0.0){return guessForT;}else{return binarySubdivide(aX,intervalStart,intervalStart+kSampleStepSize,mX1,mX2);}}}\\\";_f.__workletHash=10148290284160;global.__reanimatedWorkletInit(_f);return _f;}();return function(){var _f=function _f(x){if(mX1===mY1&&mX2===mY2){return x;}if(x===0){return 0;}if(x===1){return 1;}return calcBezier(getTForX(x),mY1,mY2);};_f._closure={mX1:mX1,mY1:mY1,mX2:mX2,mY2:mY2,calcBezier:calcBezier,getTForX:getTForX};_f.asString=\\\"function BezierEasing(x){const{mX1,mY1,mX2,mY2,calcBezier,getTForX}=jsThis._closure;{if(mX1===mY1&&mX2===mY2){return x;}if(x===0){return 0;}if(x===1){return 1;}return calcBezier(getTForX(x),mY1,mY2);}}\\\";_f.__workletHash=8676971518933;global.__reanimatedWorkletInit(_f);return _f;}();}\";\n  _f.__workletHash = 2675529951738;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.Bezier = Bezier;","map":{"version":3,"sources":["D:/Programming/React Native/drinkUp/node_modules/react-native-reanimated/src/reanimated2/Bezier.js"],"names":["Bezier","mX1","mY1","mX2","mY2","NEWTON_ITERATIONS","NEWTON_MIN_SLOPE","SUBDIVISION_PRECISION","SUBDIVISION_MAX_ITERATIONS","kSplineTableSize","kSampleStepSize","A","aA1","aA2","B","C","calcBezier","aT","getSlope","binarySubdivide","aX","aA","aB","currentX","currentT","i","Math","abs","newtonRaphsonIterate","aGuessT","currentSlope","LinearEasing","x","Error","sampleValues","Array","getTForX","intervalStart","currentSample","lastSample","dist","guessForT","initialSlope"],"mappings":"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","sourcesContent":["/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\n\nexport function Bezier(mX1, mY1, mX2, mY2) {\n  'worklet';\n\n  var NEWTON_ITERATIONS = 4;\n  var NEWTON_MIN_SLOPE = 0.001;\n  var SUBDIVISION_PRECISION = 0.0000001;\n  var SUBDIVISION_MAX_ITERATIONS = 10;\n\n  var kSplineTableSize = 11;\n  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\n  function A(aA1, aA2) {\n    'worklet';\n    return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n  }\n  function B(aA1, aA2) {\n    'worklet';\n    return 3.0 * aA2 - 6.0 * aA1;\n  }\n  function C(aA1) {\n    'worklet';\n    return 3.0 * aA1;\n  }\n\n  // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n  function calcBezier(aT, aA1, aA2) {\n    'worklet';\n    return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n  }\n\n  // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n  function getSlope(aT, aA1, aA2) {\n    'worklet';\n    return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n  }\n\n  function binarySubdivide(aX, aA, aB, mX1, mX2) {\n    'worklet';\n    var currentX;\n    var currentT;\n    var i = 0;\n    do {\n      currentT = aA + (aB - aA) / 2.0;\n      currentX = calcBezier(currentT, mX1, mX2) - aX;\n      if (currentX > 0.0) {\n        aB = currentT;\n      } else {\n        aA = currentT;\n      }\n    } while (\n      Math.abs(currentX) > SUBDIVISION_PRECISION &&\n      ++i < SUBDIVISION_MAX_ITERATIONS\n    );\n    return currentT;\n  }\n\n  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    'worklet';\n    for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n      var currentSlope = getSlope(aGuessT, mX1, mX2);\n      if (currentSlope === 0.0) {\n        return aGuessT;\n      }\n      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  }\n\n  function LinearEasing(x) {\n    'worklet';\n    return x;\n  }\n\n  if (!(mX1 >= 0 && mX1 <= 1 && mX2 >= 0 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // FIXME: Float32Array is not available in Hermes right now\n  //\n  // var float32ArraySupported = typeof Float32Array === 'function';\n  // const sampleValues = float32ArraySupported\n  // ? new Float32Array(kSplineTableSize)\n  // : new Array(kSplineTableSize);\n\n  // Precompute samples table\n  const sampleValues = new Array(kSplineTableSize);\n\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX(aX) {\n    'worklet';\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (\n      ;\n      currentSample !== lastSample && sampleValues[currentSample] <= aX;\n      ++currentSample\n    ) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist =\n      (aX - sampleValues[currentSample]) /\n      (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(\n        aX,\n        intervalStart,\n        intervalStart + kSampleStepSize,\n        mX1,\n        mX2\n      );\n    }\n  }\n\n  return function BezierEasing(x) {\n    'worklet';\n    if (mX1 === mY1 && mX2 === mY2) {\n      return x; // linear\n    }\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n}\n"]},"metadata":{},"sourceType":"script"}