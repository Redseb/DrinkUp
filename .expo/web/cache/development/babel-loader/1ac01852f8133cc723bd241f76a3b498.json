{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = createAnimatedComponent;\n\nvar _extends2 = _interopRequireDefault(require(\"@babel/runtime/helpers/extends\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nvar _reactNative = require(\"react-native\");\n\nvar _ReanimatedEventEmitter = _interopRequireDefault(require(\"./ReanimatedEventEmitter\"));\n\nvar _AnimatedEvent = _interopRequireDefault(require(\"./core/AnimatedEvent\"));\n\nvar _AnimatedNode = _interopRequireDefault(require(\"./core/AnimatedNode\"));\n\nvar _AnimatedValue = _interopRequireDefault(require(\"./core/AnimatedValue\"));\n\nvar _AnimatedProps = require(\"./core/AnimatedProps\");\n\nvar _WorkletEventHandler = _interopRequireDefault(require(\"./reanimated2/WorkletEventHandler\"));\n\nvar _invariant = _interopRequireDefault(require(\"fbjs/lib/invariant\"));\n\nvar _jsxFileName = \"D:\\\\Programming\\\\React Native\\\\drinkUp\\\\node_modules\\\\react-native-reanimated\\\\src\\\\createAnimatedComponent.js\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = (0, _getPrototypeOf2.default)(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = (0, _getPrototypeOf2.default)(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return (0, _possibleConstructorReturn2.default)(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nvar setAndForwardRef = require('react-native/Libraries/Utilities/setAndForwardRef');\n\nvar NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  var component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {}\n\nfunction hasAnimatedNodes(value) {\n  if (value instanceof _AnimatedNode.default) {\n    return true;\n  }\n\n  if (Array.isArray(value)) {\n    return value.some(function (item) {\n      return hasAnimatedNodes(item);\n    });\n  }\n\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some(function (key) {\n      return hasAnimatedNodes(value[key]);\n    });\n  }\n\n  return false;\n}\n\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return array;\n  }\n\n  var resultArr = [];\n\n  var _flattenArray = function _flattenArray(arr) {\n    arr.forEach(function (item) {\n      if (Array.isArray(item)) {\n        _flattenArray(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n\n  _flattenArray(array);\n\n  return resultArr;\n}\n\nfunction createAnimatedComponent(Component) {\n  (0, _invariant.default)(typeof Component !== 'function' || Component.prototype && Component.prototype.isReactComponent, '`createAnimatedComponent` does not support stateless functional components; ' + 'use a class component instead.');\n\n  var AnimatedComponent = function (_React$Component) {\n    (0, _inherits2.default)(AnimatedComponent, _React$Component);\n\n    var _super = _createSuper(AnimatedComponent);\n\n    function AnimatedComponent(props) {\n      var _this;\n\n      (0, _classCallCheck2.default)(this, AnimatedComponent);\n      _this = _super.call(this, props);\n      _this._invokeAnimatedPropsCallbackOnMount = false;\n\n      _this._animatedPropsCallback = function () {\n        if (_this._component == null) {\n          _this._invokeAnimatedPropsCallbackOnMount = true;\n        } else if (typeof _this._component.setNativeProps !== 'function') {\n          _this.forceUpdate();\n        } else {\n          _this._component.setNativeProps(_this._propsAnimated.__getValue());\n        }\n      };\n\n      _this._setComponentRef = setAndForwardRef({\n        getForwardedRef: function getForwardedRef() {\n          return _this.props.forwardedRef;\n        },\n        setLocalRef: function setLocalRef(ref) {\n          if (ref !== _this._component) {\n            _this._component = ref;\n          }\n\n          if (ref != null && ref.getNode == null) {\n            ref.getNode = function () {\n              var _ref$constructor$name;\n\n              console.warn('%s: Calling %s on the ref of an Animated component ' + 'is no longer necessary. You can now directly use the ref ' + 'instead. This method will be removed in a future release.', (_ref$constructor$name = ref.constructor.name) != null ? _ref$constructor$name : '<<anonymous>>', 'getNode()');\n              return ref;\n            };\n          }\n        }\n      });\n\n      _this._attachProps(_this.props);\n\n      return _this;\n    }\n\n    (0, _createClass2.default)(AnimatedComponent, [{\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        this._detachPropUpdater();\n\n        this._propsAnimated && this._propsAnimated.__detach();\n\n        this._detachNativeEvents();\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        if (this._invokeAnimatedPropsCallbackOnMount) {\n          this._invokeAnimatedPropsCallbackOnMount = false;\n\n          this._animatedPropsCallback();\n        }\n\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n\n        this._attachNativeEvents();\n\n        this._attachPropUpdater();\n\n        this._attachAnimatedStyles();\n      }\n    }, {\n      key: \"_getEventViewRef\",\n      value: function _getEventViewRef() {\n        return this._component.getScrollableNode ? this._component.getScrollableNode() : this._component;\n      }\n    }, {\n      key: \"_attachNativeEvents\",\n      value: function _attachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        var viewTag = (0, _reactNative.findNodeHandle)(node);\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.attachEvent(node, key);\n          } else if (prop instanceof _WorkletEventHandler.default) {\n            prop.registerForEvents(viewTag, key);\n          }\n        }\n      }\n    }, {\n      key: \"_detachNativeEvents\",\n      value: function _detachNativeEvents() {\n        var node = this._getEventViewRef();\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            prop.detachEvent(node, key);\n          } else if (prop instanceof _WorkletEventHandler.default) {\n            prop.unregisterFromEvents();\n          }\n        }\n      }\n    }, {\n      key: \"_reattachNativeEvents\",\n      value: function _reattachNativeEvents(prevProps) {\n        var node = this._getEventViewRef();\n\n        var attached = new Set();\n        var nextEvts = new Set();\n        var viewTag;\n\n        for (var key in this.props) {\n          var prop = this.props[key];\n\n          if (prop instanceof _AnimatedEvent.default) {\n            nextEvts.add(prop.__nodeID);\n          } else if (prop instanceof _WorkletEventHandler.default && viewTag === undefined) {\n            viewTag = prop.viewTag;\n          }\n        }\n\n        for (var _key in prevProps) {\n          var _prop = this.props[_key];\n\n          if (_prop instanceof _AnimatedEvent.default) {\n            if (!nextEvts.has(_prop.__nodeID)) {\n              _prop.detachEvent(node, _key);\n            } else {\n              attached.add(_prop.__nodeID);\n            }\n          } else if (_prop instanceof _WorkletEventHandler.default && _prop.reattachNeeded) {\n            _prop.unregisterFromEvents();\n          }\n        }\n\n        for (var _key2 in this.props) {\n          var _prop2 = this.props[_key2];\n\n          if (_prop2 instanceof _AnimatedEvent.default && !attached.has(_prop2.__nodeID)) {\n            _prop2.attachEvent(node, _key2);\n          } else if (_prop2 instanceof _WorkletEventHandler.default && _prop2.reattachNeeded) {\n            _prop2.registerForEvents(viewTag, _key2);\n\n            _prop2.reattachNeeded = false;\n          }\n        }\n      }\n    }, {\n      key: \"_attachProps\",\n      value: function _attachProps(nextProps) {\n        var oldPropsAnimated = this._propsAnimated;\n        this._propsAnimated = (0, _AnimatedProps.createOrReusePropsNode)(nextProps, this._animatedPropsCallback, oldPropsAnimated);\n\n        if (oldPropsAnimated !== this._propsAnimated) {\n          oldPropsAnimated && oldPropsAnimated.__detach();\n        }\n      }\n    }, {\n      key: \"_updateFromNative\",\n      value: function _updateFromNative(props) {\n        this._component.setNativeProps(props);\n      }\n    }, {\n      key: \"_attachPropUpdater\",\n      value: function _attachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.set(viewTag, this);\n\n        if (NODE_MAPPING.size === 1) {\n          _ReanimatedEventEmitter.default.addListener('onReanimatedPropsChange', listener);\n        }\n      }\n    }, {\n      key: \"_attachAnimatedStyles\",\n      value: function _attachAnimatedStyles() {\n        var styles = Array.isArray(this.props.style) ? this.props.style : [this.props.style];\n        styles = flattenArray(styles);\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        styles.forEach(function (style) {\n          if (style && style.viewTag !== undefined) {\n            style.viewTag.value = viewTag;\n          }\n        });\n\n        if (this.props.animatedProps) {\n          this.props.animatedProps.viewTag.value = viewTag;\n        }\n      }\n    }, {\n      key: \"_detachPropUpdater\",\n      value: function _detachPropUpdater() {\n        var viewTag = (0, _reactNative.findNodeHandle)(this);\n        NODE_MAPPING.delete(viewTag);\n\n        if (NODE_MAPPING.size === 0) {\n          _ReanimatedEventEmitter.default.removeAllListeners('onReanimatedPropsChange');\n        }\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps) {\n        this._attachProps(this.props);\n\n        this._reattachNativeEvents(prevProps);\n\n        this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n      }\n    }, {\n      key: \"_filterNonAnimatedStyle\",\n      value: function _filterNonAnimatedStyle(inputStyle) {\n        var style = {};\n\n        for (var key in inputStyle) {\n          var value = inputStyle[key];\n\n          if (!hasAnimatedNodes(value)) {\n            style[key] = value;\n          } else if (value instanceof _AnimatedValue.default) {\n            style[key] = value._startingValue;\n          }\n        }\n\n        return style;\n      }\n    }, {\n      key: \"_filterNonAnimatedProps\",\n      value: function _filterNonAnimatedProps(inputProps) {\n        var _this2 = this;\n\n        var props = {};\n\n        var _loop = function _loop(key) {\n          var value = inputProps[key];\n\n          if (key === 'style') {\n            var styles = Array.isArray(value) ? value : [value];\n            var processedStyle = styles.map(function (style) {\n              if (style && style.viewTag) {\n                if (style.viewRef.current === null) {\n                  style.viewRef.current = _this2;\n                }\n\n                return style.initial;\n              } else {\n                return style;\n              }\n            });\n            props[key] = _this2._filterNonAnimatedStyle(_reactNative.StyleSheet.flatten(processedStyle));\n          } else if (key === 'animatedProps') {\n            Object.keys(value.initial).forEach(function (key) {\n              props[key] = value.initial[key];\n            });\n          } else if (value instanceof _AnimatedEvent.default) {\n            props[key] = dummyListener;\n          } else if (value instanceof _WorkletEventHandler.default) {\n            if (value.eventNames.length > 0) {\n              value.eventNames.forEach(function (eventName) {\n                props[eventName] = value.listeners ? value.listeners[eventName] : dummyListener;\n              });\n            } else {\n              props[key] = dummyListener;\n            }\n          } else if (!(value instanceof _AnimatedNode.default)) {\n            props[key] = value;\n          } else if (value instanceof _AnimatedValue.default) {\n            props[key] = value._startingValue;\n          }\n        };\n\n        for (var key in inputProps) {\n          _loop(key);\n        }\n\n        return props;\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var props = this._filterNonAnimatedProps(this.props);\n\n        var platformProps = _reactNative.Platform.select({\n          web: {},\n          default: {\n            collapsable: false\n          }\n        });\n\n        return _react.default.createElement(Component, (0, _extends2.default)({}, props, {\n          ref: this._setComponentRef\n        }, platformProps, {\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 354,\n            columnNumber: 9\n          }\n        }));\n      }\n    }]);\n    return AnimatedComponent;\n  }(_react.default.Component);\n\n  AnimatedComponent.displayName = \"AnimatedComponent(\" + (Component.displayName || Component.name || 'Component') + \")\";\n  return _react.default.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return _react.default.createElement(AnimatedComponent, (0, _extends2.default)({}, props, ref == null ? null : {\n      forwardedRef: ref\n    }, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 365,\n        columnNumber: 7\n      }\n    }));\n  });\n}","map":{"version":3,"sources":["D:/Programming/React Native/drinkUp/node_modules/react-native-reanimated/src/createAnimatedComponent.js"],"names":["setAndForwardRef","require","NODE_MAPPING","Map","listener","data","component","get","viewTag","_updateFromNative","props","dummyListener","hasAnimatedNodes","value","AnimatedNode","Array","isArray","some","item","Object","keys","key","flattenArray","array","resultArr","_flattenArray","arr","forEach","push","createAnimatedComponent","Component","prototype","isReactComponent","AnimatedComponent","_invokeAnimatedPropsCallbackOnMount","_animatedPropsCallback","_component","setNativeProps","forceUpdate","_propsAnimated","__getValue","_setComponentRef","getForwardedRef","forwardedRef","setLocalRef","ref","getNode","console","warn","constructor","name","_attachProps","_detachPropUpdater","__detach","_detachNativeEvents","setNativeView","_attachNativeEvents","_attachPropUpdater","_attachAnimatedStyles","getScrollableNode","node","_getEventViewRef","prop","AnimatedEvent","attachEvent","WorkletEventHandler","registerForEvents","detachEvent","unregisterFromEvents","prevProps","attached","Set","nextEvts","add","__nodeID","undefined","has","reattachNeeded","nextProps","oldPropsAnimated","set","size","ReanimatedEventEmitter","addListener","styles","style","animatedProps","delete","removeAllListeners","_reattachNativeEvents","inputStyle","AnimatedValue","_startingValue","inputProps","processedStyle","map","viewRef","current","initial","_filterNonAnimatedStyle","StyleSheet","flatten","eventNames","length","eventName","listeners","_filterNonAnimatedProps","platformProps","Platform","select","web","default","collapsable","React","displayName","forwardRef","AnimatedComponentWrapper"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { findNodeHandle, Platform, StyleSheet } from 'react-native';\nimport ReanimatedEventEmitter from './ReanimatedEventEmitter';\n\nimport AnimatedEvent from './core/AnimatedEvent';\nimport AnimatedNode from './core/AnimatedNode';\nimport AnimatedValue from './core/AnimatedValue';\nimport { createOrReusePropsNode } from './core/AnimatedProps';\nimport WorkletEventHandler from './reanimated2/WorkletEventHandler';\n\nimport invariant from 'fbjs/lib/invariant';\n\nconst setAndForwardRef = require('react-native/Libraries/Utilities/setAndForwardRef');\n\nconst NODE_MAPPING = new Map();\n\nfunction listener(data) {\n  const component = NODE_MAPPING.get(data.viewTag);\n  component && component._updateFromNative(data.props);\n}\n\nfunction dummyListener() {\n  // empty listener we use to assign to listener properties for which animated\n  // event is used.\n}\n\nfunction hasAnimatedNodes(value) {\n  if (value instanceof AnimatedNode) {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.some((item) => hasAnimatedNodes(item));\n  }\n  if (value && typeof value === 'object') {\n    return Object.keys(value).some((key) => hasAnimatedNodes(value[key]));\n  }\n  return false;\n}\n\nfunction flattenArray(array) {\n  if (!Array.isArray(array)) {\n    return array;\n  }\n  const resultArr = [];\n\n  const _flattenArray = (arr) => {\n    arr.forEach((item) => {\n      if (Array.isArray(item)) {\n        _flattenArray(item);\n      } else {\n        resultArr.push(item);\n      }\n    });\n  };\n  _flattenArray(array);\n  return resultArr;\n}\n\nexport default function createAnimatedComponent(Component) {\n  invariant(\n    typeof Component !== 'function' ||\n      (Component.prototype && Component.prototype.isReactComponent),\n    '`createAnimatedComponent` does not support stateless functional components; ' +\n      'use a class component instead.'\n  );\n\n  class AnimatedComponent extends React.Component {\n    _invokeAnimatedPropsCallbackOnMount = false;\n\n    constructor(props) {\n      super(props);\n      this._attachProps(this.props);\n    }\n\n    componentWillUnmount() {\n      this._detachPropUpdater();\n      this._propsAnimated && this._propsAnimated.__detach();\n      this._detachNativeEvents();\n    }\n\n    componentDidMount() {\n      if (this._invokeAnimatedPropsCallbackOnMount) {\n        this._invokeAnimatedPropsCallbackOnMount = false;\n        this._animatedPropsCallback();\n      }\n\n      this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n      this._attachNativeEvents();\n      this._attachPropUpdater();\n      this._attachAnimatedStyles();\n    }\n\n    _getEventViewRef() {\n      // Make sure to get the scrollable node for components that implement\n      // `ScrollResponder.Mixin`.\n      return this._component.getScrollableNode\n        ? this._component.getScrollableNode()\n        : this._component;\n    }\n\n    _attachNativeEvents() {\n      const node = this._getEventViewRef();\n      const viewTag = findNodeHandle(node);\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.attachEvent(node, key);\n        } else if (prop instanceof WorkletEventHandler) {\n          prop.registerForEvents(viewTag, key);\n        }\n      }\n    }\n\n    _detachNativeEvents() {\n      const node = this._getEventViewRef();\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          prop.detachEvent(node, key);\n        } else if (prop instanceof WorkletEventHandler) {\n          prop.unregisterFromEvents();\n        }\n      }\n    }\n\n    _reattachNativeEvents(prevProps) {\n      const node = this._getEventViewRef();\n      const attached = new Set();\n      const nextEvts = new Set();\n      let viewTag;\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          nextEvts.add(prop.__nodeID);\n        } else if (\n          prop instanceof WorkletEventHandler &&\n          viewTag === undefined\n        ) {\n          viewTag = prop.viewTag;\n        }\n      }\n      for (const key in prevProps) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent) {\n          if (!nextEvts.has(prop.__nodeID)) {\n            // event was in prev props but not in current props, we detach\n            prop.detachEvent(node, key);\n          } else {\n            // event was in prev and is still in current props\n            attached.add(prop.__nodeID);\n          }\n        } else if (prop instanceof WorkletEventHandler && prop.reattachNeeded) {\n          prop.unregisterFromEvents();\n        }\n      }\n\n      for (const key in this.props) {\n        const prop = this.props[key];\n        if (prop instanceof AnimatedEvent && !attached.has(prop.__nodeID)) {\n          // not yet attached\n          prop.attachEvent(node, key);\n        } else if (prop instanceof WorkletEventHandler && prop.reattachNeeded) {\n          prop.registerForEvents(viewTag, key);\n          prop.reattachNeeded = false;\n        }\n      }\n    }\n\n    // The system is best designed when setNativeProps is implemented. It is\n    // able to avoid re-rendering and directly set the attributes that changed.\n    // However, setNativeProps can only be implemented on native components\n    // If you want to animate a composite component, you need to re-render it.\n    // In this case, we have a fallback that uses forceUpdate.\n    _animatedPropsCallback = () => {\n      if (this._component == null) {\n        // AnimatedProps is created in will-mount because it's used in render.\n        // But this callback may be invoked before mount in async mode,\n        // In which case we should defer the setNativeProps() call.\n        // React may throw away uncommitted work in async mode,\n        // So a deferred call won't always be invoked.\n        this._invokeAnimatedPropsCallbackOnMount = true;\n      } else if (typeof this._component.setNativeProps !== 'function') {\n        this.forceUpdate();\n      } else {\n        this._component.setNativeProps(this._propsAnimated.__getValue());\n      }\n    };\n\n    _attachProps(nextProps) {\n      const oldPropsAnimated = this._propsAnimated;\n\n      this._propsAnimated = createOrReusePropsNode(\n        nextProps,\n        this._animatedPropsCallback,\n        oldPropsAnimated\n      );\n      // If prop node has been reused we don't need to call into \"__detach\"\n      if (oldPropsAnimated !== this._propsAnimated) {\n        // When you call detach, it removes the element from the parent list\n        // of children. If it goes to 0, then the parent also detaches itself\n        // and so on.\n        // An optimization is to attach the new elements and THEN detach the old\n        // ones instead of detaching and THEN attaching.\n        // This way the intermediate state isn't to go to 0 and trigger\n        // this expensive recursive detaching to then re-attach everything on\n        // the very next operation.\n        oldPropsAnimated && oldPropsAnimated.__detach();\n      }\n    }\n\n    _updateFromNative(props) {\n      this._component.setNativeProps(props);\n    }\n\n    _attachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.set(viewTag, this);\n      if (NODE_MAPPING.size === 1) {\n        ReanimatedEventEmitter.addListener('onReanimatedPropsChange', listener);\n      }\n    }\n\n    _attachAnimatedStyles() {\n      let styles = Array.isArray(this.props.style)\n        ? this.props.style\n        : [this.props.style];\n      styles = flattenArray(styles);\n      const viewTag = findNodeHandle(this);\n      styles.forEach((style) => {\n        if (style && style.viewTag !== undefined) {\n          style.viewTag.value = viewTag;\n        }\n      });\n      // attach animatedProps property\n      if (this.props.animatedProps) {\n        this.props.animatedProps.viewTag.value = viewTag;\n      }\n    }\n\n    _detachPropUpdater() {\n      const viewTag = findNodeHandle(this);\n      NODE_MAPPING.delete(viewTag);\n      if (NODE_MAPPING.size === 0) {\n        ReanimatedEventEmitter.removeAllListeners('onReanimatedPropsChange');\n      }\n    }\n\n    componentDidUpdate(prevProps) {\n      this._attachProps(this.props);\n      this._reattachNativeEvents(prevProps);\n\n      this._propsAnimated && this._propsAnimated.setNativeView(this._component);\n    }\n\n    _setComponentRef = setAndForwardRef({\n      getForwardedRef: () => this.props.forwardedRef,\n      setLocalRef: (ref) => {\n        if (ref !== this._component) {\n          this._component = ref;\n        }\n\n        // TODO: Delete this after React Native also deletes this deprecation helper.\n        if (ref != null && ref.getNode == null) {\n          ref.getNode = () => {\n            console.warn(\n              '%s: Calling %s on the ref of an Animated component ' +\n                'is no longer necessary. You can now directly use the ref ' +\n                'instead. This method will be removed in a future release.',\n              ref.constructor.name ?? '<<anonymous>>',\n              'getNode()'\n            );\n            return ref;\n          };\n        }\n      },\n    });\n\n    _filterNonAnimatedStyle(inputStyle) {\n      const style = {};\n      for (const key in inputStyle) {\n        const value = inputStyle[key];\n        if (!hasAnimatedNodes(value)) {\n          style[key] = value;\n        } else if (value instanceof AnimatedValue) {\n          // if any style in animated component is set directly to the `Value` we set those styles to the first value of `Value` node in order\n          // to avoid flash of default styles when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n          style[key] = value._startingValue;\n        }\n      }\n      return style;\n    }\n\n    _filterNonAnimatedProps(inputProps) {\n      const props = {};\n      for (const key in inputProps) {\n        const value = inputProps[key];\n        if (key === 'style') {\n          const styles = Array.isArray(value) ? value : [value];\n          const processedStyle = styles.map((style) => {\n            if (style && style.viewTag) {\n              // this is how we recognize styles returned by useAnimatedStyle\n              if (style.viewRef.current === null) {\n                style.viewRef.current = this;\n              }\n              return style.initial;\n            } else {\n              return style;\n            }\n          });\n          props[key] = this._filterNonAnimatedStyle(\n            StyleSheet.flatten(processedStyle)\n          );\n        } else if (key === 'animatedProps') {\n          Object.keys(value.initial).forEach((key) => {\n            props[key] = value.initial[key];\n          });\n        } else if (value instanceof AnimatedEvent) {\n          // we cannot filter out event listeners completely as some components\n          // rely on having a callback registered in order to generate events\n          // alltogether. Therefore we provide a dummy callback here to allow\n          // native event dispatcher to hijack events.\n          props[key] = dummyListener;\n        } else if (value instanceof WorkletEventHandler) {\n          if (value.eventNames.length > 0) {\n            value.eventNames.forEach((eventName) => {\n              props[eventName] = value.listeners\n                ? value.listeners[eventName]\n                : dummyListener;\n            });\n          } else {\n            props[key] = dummyListener;\n          }\n        } else if (!(value instanceof AnimatedNode)) {\n          props[key] = value;\n        } else if (value instanceof AnimatedValue) {\n          // if any prop in animated component is set directly to the `Value` we set those props to the first value of `Value` node in order\n          // to avoid default values for a short moment when `Value` is being asynchrounously sent via bridge and initialized in the native side.\n          props[key] = value._startingValue;\n        }\n      }\n      return props;\n    }\n\n    render() {\n      const props = this._filterNonAnimatedProps(this.props);\n      const platformProps = Platform.select({\n        web: {},\n        default: { collapsable: false },\n      });\n      return (\n        <Component {...props} ref={this._setComponentRef} {...platformProps} />\n      );\n    }\n  }\n\n  AnimatedComponent.displayName = `AnimatedComponent(${Component.displayName ||\n    Component.name ||\n    'Component'})`;\n\n  return React.forwardRef(function AnimatedComponentWrapper(props, ref) {\n    return (\n      <AnimatedComponent\n        {...props}\n        {...(ref == null ? null : { forwardedRef: ref })}\n      />\n    );\n  });\n}\n"]},"metadata":{},"sourceType":"script"}