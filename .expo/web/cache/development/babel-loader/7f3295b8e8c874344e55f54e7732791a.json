{"ast":null,"code":"Object.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.interpolate = void 0;\n\nvar _interpolate = require(\"../derived/interpolate\");\n\nvar internalInterpolate = function () {\n  var _f = function _f(x, l, r, ll, rr, type) {\n    if (r - l === 0) return ll;\n    var progress = (x - l) / (r - l);\n    var val = ll + progress * (rr - ll);\n    var coef = rr >= ll ? 1 : -1;\n    type = type || _interpolate.Extrapolate.EXTEND;\n\n    if (coef * val < coef * ll || coef * val > coef * rr) {\n      switch (type) {\n        case _interpolate.Extrapolate.IDENTITY:\n          return x;\n\n        case _interpolate.Extrapolate.CLAMP:\n          if (coef * val < coef * ll) {\n            return ll;\n          }\n\n          return rr;\n\n        case _interpolate.Extrapolate.EXTEND:\n        default:\n          return val;\n      }\n    }\n\n    return val;\n  };\n\n  _f._closure = {\n    Extrapolate: {\n      EXTEND: _interpolate.Extrapolate.EXTEND,\n      IDENTITY: _interpolate.Extrapolate.IDENTITY,\n      CLAMP: _interpolate.Extrapolate.CLAMP\n    }\n  };\n  _f.asString = \"function internalInterpolate(x,l,r,ll,rr,type){const{Extrapolate}=jsThis._closure;{if(r-l===0)return ll;var progress=(x-l)/(r-l);var val=ll+progress*(rr-ll);var coef=rr>=ll?1:-1;type=type||Extrapolate.EXTEND;if(coef*val<coef*ll||coef*val>coef*rr){switch(type){case Extrapolate.IDENTITY:return x;case Extrapolate.CLAMP:if(coef*val<coef*ll){return ll;}return rr;case Extrapolate.EXTEND:default:return val;}}return val;}}\";\n  _f.__workletHash = 16794550962941;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar interpolate = function () {\n  var _f = function _f(x, input, output, type) {\n    if (x && x.__nodeID) {\n      throw new Error('Reanimated: interpolate from V1 has been renamed to interpolateNode.');\n    }\n\n    var length = input.length;\n    var narrowedInput = [];\n\n    if (x < input[0]) {\n      narrowedInput = [input[0], input[1], output[0], output[1]];\n    } else if (x > input[length - 1]) {\n      narrowedInput = [input[length - 2], input[length - 1], output[length - 2], output[length - 1]];\n    } else {\n      for (var i = 1; i < length; ++i) {\n        if (x <= input[i]) {\n          narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n          break;\n        }\n      }\n    }\n\n    return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n  };\n\n  _f._closure = {\n    internalInterpolate: internalInterpolate\n  };\n  _f.asString = \"function interpolate(x,input,output,type){const{internalInterpolate}=jsThis._closure;{if(x&&x.__nodeID){throw new Error('Reanimated: interpolate from V1 has been renamed to interpolateNode.');}var length=input.length;var narrowedInput=[];if(x<input[0]){narrowedInput=[input[0],input[1],output[0],output[1]];}else if(x>input[length-1]){narrowedInput=[input[length-2],input[length-1],output[length-2],output[length-1]];}else{for(var i=1;i<length;++i){if(x<=input[i]){narrowedInput=[input[i-1],input[i],output[i-1],output[i]];break;}}}return internalInterpolate.apply({},[x].concat(narrowedInput).concat(type));}}\";\n  _f.__workletHash = 13867398897915;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.interpolate = interpolate;","map":{"version":3,"sources":["D:/Programming/React Native/drinkUp/node_modules/react-native-reanimated/src/reanimated2/interpolation.js"],"names":["internalInterpolate","x","l","r","ll","rr","type","progress","val","coef","Extrapolate","EXTEND","IDENTITY","CLAMP","interpolate","input","output","__nodeID","Error","length","narrowedInput","i","apply","concat"],"mappings":";;;;;AAAA;;IAESA,mB;uBAAoBC,C,EAAGC,C,EAAGC,C,EAAGC,E,EAAIC,E,EAAIC,I,EAAM;AAElD,QAAIH,CAAC,GAAGD,CAAJ,KAAU,CAAd,EAAiB,OAAOE,EAAP;AACjB,QAAMG,QAAQ,GAAG,CAACN,CAAC,GAAGC,CAAL,KAAWC,CAAC,GAAGD,CAAf,CAAjB;AACA,QAAMM,GAAG,GAAGJ,EAAE,GAAGG,QAAQ,IAAIF,EAAE,GAAGD,EAAT,CAAzB;AACA,QAAMK,IAAI,GAAGJ,EAAE,IAAID,EAAN,GAAW,CAAX,GAAe,CAAC,CAA7B;AAIAE,IAAAA,IAAI,GAAGA,IAAI,IAAII,yBAAYC,MAA3B;;AAEA,QAAIF,IAAI,GAAGD,GAAP,GAAaC,IAAI,GAAGL,EAApB,IAA0BK,IAAI,GAAGD,GAAP,GAAaC,IAAI,GAAGJ,EAAlD,EAAsD;AACpD,cAAQC,IAAR;AACE,aAAKI,yBAAYE,QAAjB;AACE,iBAAOX,CAAP;;AACF,aAAKS,yBAAYG,KAAjB;AACE,cAAIJ,IAAI,GAAGD,GAAP,GAAaC,IAAI,GAAGL,EAAxB,EAA4B;AAC1B,mBAAOA,EAAP;AACD;;AACD,iBAAOC,EAAP;;AACF,aAAKK,yBAAYC,MAAjB;AACA;AACE,iBAAOH,GAAP;AAVJ;AAYD;;AACD,WAAOA,GAAP;AACD,G;;;;cAJUE,yBAAYC,M;gBAVZD,yBAAYE,Q;aAGZF,yBAAYG;;;;;;;;;;;IAaPC,W;uBAAYb,C,EAAGc,K,EAAOC,M,EAAQV,I,EAAM;AAElD,QAAIL,CAAC,IAAIA,CAAC,CAACgB,QAAX,EAAqB;AACnB,YAAM,IAAIC,KAAJ,CACJ,sEADI,CAAN;AAGD;;AACD,QAAMC,MAAM,GAAGJ,KAAK,CAACI,MAArB;AACA,QAAIC,aAAa,GAAG,EAApB;;AACA,QAAInB,CAAC,GAAGc,KAAK,CAAC,CAAD,CAAb,EAAkB;AAChBK,MAAAA,aAAa,GAAG,CAACL,KAAK,CAAC,CAAD,CAAN,EAAWA,KAAK,CAAC,CAAD,CAAhB,EAAqBC,MAAM,CAAC,CAAD,CAA3B,EAAgCA,MAAM,CAAC,CAAD,CAAtC,CAAhB;AACD,KAFD,MAEO,IAAIf,CAAC,GAAGc,KAAK,CAACI,MAAM,GAAG,CAAV,CAAb,EAA2B;AAChCC,MAAAA,aAAa,GAAG,CACdL,KAAK,CAACI,MAAM,GAAG,CAAV,CADS,EAEdJ,KAAK,CAACI,MAAM,GAAG,CAAV,CAFS,EAGdH,MAAM,CAACG,MAAM,GAAG,CAAV,CAHQ,EAIdH,MAAM,CAACG,MAAM,GAAG,CAAV,CAJQ,CAAhB;AAMD,KAPM,MAOA;AACL,WAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,MAApB,EAA4B,EAAEE,CAA9B,EAAiC;AAC/B,YAAIpB,CAAC,IAAIc,KAAK,CAACM,CAAD,CAAd,EAAmB;AACjBD,UAAAA,aAAa,GAAG,CAACL,KAAK,CAACM,CAAC,GAAG,CAAL,CAAN,EAAeN,KAAK,CAACM,CAAD,CAApB,EAAyBL,MAAM,CAACK,CAAC,GAAG,CAAL,CAA/B,EAAwCL,MAAM,CAACK,CAAD,CAA9C,CAAhB;AACA;AACD;AACF;AACF;;AACD,WAAOrB,mBAAmB,CAACsB,KAApB,CAA0B,EAA1B,EAA8B,CAACrB,CAAD,EAAIsB,MAAJ,CAAWH,aAAX,EAA0BG,MAA1B,CAAiCjB,IAAjC,CAA9B,CAAP;AACD,G;;;yBAjCQN","sourcesContent":["import { Extrapolate } from '../derived/interpolate';\n\nfunction internalInterpolate(x, l, r, ll, rr, type) {\n  'worklet';\n  if (r - l === 0) return ll;\n  const progress = (x - l) / (r - l);\n  const val = ll + progress * (rr - ll);\n  const coef = rr >= ll ? 1 : -1;\n\n  // TODO: support default values in worklets:\n  // e.g. function interplate(x, input, output, type = Extrapolate.CLAMP)\n  type = type || Extrapolate.EXTEND;\n\n  if (coef * val < coef * ll || coef * val > coef * rr) {\n    switch (type) {\n      case Extrapolate.IDENTITY:\n        return x;\n      case Extrapolate.CLAMP:\n        if (coef * val < coef * ll) {\n          return ll;\n        }\n        return rr;\n      case Extrapolate.EXTEND:\n      default:\n        return val;\n    }\n  }\n  return val;\n}\n\nexport function interpolate(x, input, output, type) {\n  'worklet';\n  if (x && x.__nodeID) {\n    throw new Error(\n      'Reanimated: interpolate from V1 has been renamed to interpolateNode.'\n    );\n  }\n  const length = input.length;\n  let narrowedInput = [];\n  if (x < input[0]) {\n    narrowedInput = [input[0], input[1], output[0], output[1]];\n  } else if (x > input[length - 1]) {\n    narrowedInput = [\n      input[length - 2],\n      input[length - 1],\n      output[length - 2],\n      output[length - 1],\n    ];\n  } else {\n    for (let i = 1; i < length; ++i) {\n      if (x <= input[i]) {\n        narrowedInput = [input[i - 1], input[i], output[i - 1], output[i]];\n        break;\n      }\n    }\n  }\n  return internalInterpolate.apply({}, [x].concat(narrowedInput).concat(type));\n}\n"]},"metadata":{},"sourceType":"script"}