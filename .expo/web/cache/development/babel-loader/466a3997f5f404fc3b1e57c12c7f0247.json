{"ast":null,"code":"var _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initialUpdaterRun = initialUpdaterRun;\nexports.loop = exports.repeat = exports.sequence = exports.delay = exports.withDecay = exports.withSpring = exports.withTiming = exports.cancelAnimation = void 0;\n\nvar _Easing = require(\"./Easing\");\n\nvar _NativeReanimated = _interopRequireDefault(require(\"./NativeReanimated\"));\n\nvar IN_STYLE_UPDATER = false;\n\nvar assertNumber = function () {\n  var _f = function _f(value, callerName) {\n    var valueType = typeof value;\n\n    if (valueType !== 'number') {\n      var error = \"invalid type of toValue passed to \" + callerName + \", expected `number`, got `\" + valueType + \"`\";\n\n      if (valueType === 'object') {\n        error += ', maybe you forgot to add `.value`?';\n      }\n\n      throw new Error(error);\n    }\n  };\n\n  _f._closure = {};\n  _f.asString = \"function _f(value,callerName){var valueType=typeof value;if(valueType!=='number'){var error=\\\"invalid type of toValue passed to \\\"+callerName+\\\", expected `number`, got `\\\"+valueType+\\\"`\\\";if(valueType==='object'){error+=', maybe you forgot to add `.value`?';}throw new Error(error);}}\";\n  _f.__workletHash = 2182622201201;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nfunction initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  var result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\nvar defineAnimation = function () {\n  var _f = function _f(starting, factory) {\n    if (IN_STYLE_UPDATER) {\n      return starting;\n    }\n\n    if (_WORKLET || !_NativeReanimated.default.native) {\n      return factory();\n    }\n\n    return factory;\n  };\n\n  _f._closure = {\n    IN_STYLE_UPDATER: IN_STYLE_UPDATER,\n    NativeReanimated: {\n      native: _NativeReanimated.default.native\n    }\n  };\n  _f.asString = \"function defineAnimation(starting,factory){const{IN_STYLE_UPDATER,NativeReanimated}=jsThis._closure;{if(IN_STYLE_UPDATER){return starting;}if(_WORKLET||!NativeReanimated.native){return factory();}return factory;}}\";\n  _f.__workletHash = 11565155752964;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nvar cancelAnimation = function () {\n  var _f = function _f(sharedValue) {\n    sharedValue.value = sharedValue.value;\n  };\n\n  _f._closure = {};\n  _f.asString = \"function cancelAnimation(sharedValue){sharedValue.value=sharedValue.value;}\";\n  _f.__workletHash = 15056882569526;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.cancelAnimation = cancelAnimation;\n\nvar withTiming = function () {\n  var _f = function _f(toValue, userConfig, callback) {\n    assertNumber(toValue, 'withTiming');\n    return defineAnimation(toValue, function () {\n      var _f = function _f() {\n        var config = {\n          duration: 300,\n          easing: _Easing.Easing.inOut(_Easing.Easing.quad)\n        };\n\n        if (userConfig) {\n          Object.keys(userConfig).forEach(function (key) {\n            return config[key] = userConfig[key];\n          });\n        }\n\n        function timing(animation, now) {\n          var toValue = animation.toValue,\n              progress = animation.progress,\n              startTime = animation.startTime,\n              current = animation.current;\n          var runtime = now - startTime;\n\n          if (runtime >= config.duration) {\n            animation.startTime = 0;\n            animation.current = toValue;\n            return true;\n          }\n\n          var newProgress = config.easing(runtime / config.duration);\n          var dist = (toValue - current) * (newProgress - progress) / (1 - progress);\n          animation.current += dist;\n          animation.progress = newProgress;\n          return false;\n        }\n\n        function start(animation, value, now, previousAnimation) {\n          if (previousAnimation && previousAnimation.type === 'timing' && previousAnimation.toValue === toValue && previousAnimation.startTime) {\n            animation.startTime = previousAnimation.startTime;\n            animation.progress = previousAnimation.progress;\n          } else {\n            animation.startTime = now;\n            animation.progress = 0;\n          }\n\n          animation.current = value;\n        }\n\n        return {\n          type: 'timing',\n          animation: timing,\n          start: start,\n          progress: 0,\n          toValue: toValue,\n          current: toValue,\n          callback: callback\n        };\n      };\n\n      _f._closure = {\n        Easing: {\n          inOut: _Easing.Easing.inOut,\n          quad: _Easing.Easing.quad\n        },\n        userConfig: userConfig,\n        toValue: toValue,\n        callback: callback\n      };\n      _f.asString = \"function _f(){const{Easing,userConfig,toValue,callback}=jsThis._closure;{var config={duration:300,easing:Easing.inOut(Easing.quad)};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}function timing(animation,now){var toValue=animation.toValue,progress=animation.progress,startTime=animation.startTime,current=animation.current;var runtime=now-startTime;if(runtime>=config.duration){animation.startTime=0;animation.current=toValue;return true;}var newProgress=config.easing(runtime/config.duration);var dist=(toValue-current)*(newProgress-progress)/(1-progress);animation.current+=dist;animation.progress=newProgress;return false;}function start(animation,value,now,previousAnimation){if(previousAnimation&&previousAnimation.type==='timing'&&previousAnimation.toValue===toValue&&previousAnimation.startTime){animation.startTime=previousAnimation.startTime;animation.progress=previousAnimation.progress;}else{animation.startTime=now;animation.progress=0;}animation.current=value;}return{type:'timing',animation:timing,start:start,progress:0,toValue:toValue,current:toValue,callback:callback};}}\";\n      _f.__workletHash = 895207684401;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }());\n  };\n\n  _f._closure = {\n    assertNumber: assertNumber,\n    defineAnimation: defineAnimation,\n    Easing: {\n      inOut: _Easing.Easing.inOut,\n      quad: _Easing.Easing.quad\n    }\n  };\n  _f.asString = \"function withTiming(toValue,userConfig,callback){const{assertNumber,defineAnimation,Easing}=jsThis._closure;{assertNumber(toValue,'withTiming');return defineAnimation(toValue,function(){var _f=function _f(){var config={duration:300,easing:Easing.inOut(Easing.quad)};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}function timing(animation,now){var toValue=animation.toValue,progress=animation.progress,startTime=animation.startTime,current=animation.current;var runtime=now-startTime;if(runtime>=config.duration){animation.startTime=0;animation.current=toValue;return true;}var newProgress=config.easing(runtime/config.duration);var dist=(toValue-current)*(newProgress-progress)/(1-progress);animation.current+=dist;animation.progress=newProgress;return false;}function start(animation,value,now,previousAnimation){if(previousAnimation&&previousAnimation.type==='timing'&&previousAnimation.toValue===toValue&&previousAnimation.startTime){animation.startTime=previousAnimation.startTime;animation.progress=previousAnimation.progress;}else{animation.startTime=now;animation.progress=0;}animation.current=value;}return{type:'timing',animation:timing,start:start,progress:0,toValue:toValue,current:toValue,callback:callback};};_f._closure={Easing:{inOut:Easing.inOut,quad:Easing.quad},userConfig:userConfig,toValue:toValue,callback:callback};_f.asString=\\\"function _f(){const{Easing,userConfig,toValue,callback}=jsThis._closure;{var config={duration:300,easing:Easing.inOut(Easing.quad)};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}function timing(animation,now){var toValue=animation.toValue,progress=animation.progress,startTime=animation.startTime,current=animation.current;var runtime=now-startTime;if(runtime>=config.duration){animation.startTime=0;animation.current=toValue;return true;}var newProgress=config.easing(runtime/config.duration);var dist=(toValue-current)*(newProgress-progress)/(1-progress);animation.current+=dist;animation.progress=newProgress;return false;}function start(animation,value,now,previousAnimation){if(previousAnimation&&previousAnimation.type==='timing'&&previousAnimation.toValue===toValue&&previousAnimation.startTime){animation.startTime=previousAnimation.startTime;animation.progress=previousAnimation.progress;}else{animation.startTime=now;animation.progress=0;}animation.current=value;}return{type:'timing',animation:timing,start:start,progress:0,toValue:toValue,current:toValue,callback:callback};}}\\\";_f.__workletHash=895207684401;global.__reanimatedWorkletInit(_f);return _f;}());}}\";\n  _f.__workletHash = 10042577287221;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.withTiming = withTiming;\n\nvar withSpring = function () {\n  var _f = function _f(toValue, userConfig, callback) {\n    assertNumber(toValue, 'withSpring');\n    return defineAnimation(toValue, function () {\n      var _f = function _f() {\n        var config = {\n          damping: 10,\n          mass: 1,\n          stiffness: 100,\n          overshootClamping: false,\n          restDisplacementThreshold: 0.001,\n          restSpeedThreshold: 0.001\n        };\n\n        if (userConfig) {\n          Object.keys(userConfig).forEach(function (key) {\n            return config[key] = userConfig[key];\n          });\n        }\n\n        function spring(animation, now) {\n          var toValue = animation.toValue,\n              lastTimestamp = animation.lastTimestamp,\n              current = animation.current,\n              velocity = animation.velocity;\n          var deltaTime = Math.min(now - lastTimestamp, 64);\n          animation.lastTimestamp = now;\n          var c = config.damping;\n          var m = config.mass;\n          var k = config.stiffness;\n          var v0 = -velocity;\n          var x0 = toValue - current;\n          var zeta = c / (2 * Math.sqrt(k * m));\n          var omega0 = Math.sqrt(k / m);\n          var omega1 = omega0 * Math.sqrt(1 - Math.pow(zeta, 2));\n          var t = deltaTime / 1000;\n          var sin1 = Math.sin(omega1 * t);\n          var cos1 = Math.cos(omega1 * t);\n          var underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n          var underDampedFrag1 = underDampedEnvelope * (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n          var underDampedPosition = toValue - underDampedFrag1;\n          var underDampedVelocity = zeta * omega0 * underDampedFrag1 - underDampedEnvelope * (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n          var criticallyDampedEnvelope = Math.exp(-omega0 * t);\n          var criticallyDampedPosition = toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n          var criticallyDampedVelocity = criticallyDampedEnvelope * (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n\n          var isOvershooting = function isOvershooting() {\n            if (config.overshootClamping && config.stiffness !== 0) {\n              return current < toValue ? animation.current > toValue : animation.current < toValue;\n            } else {\n              return false;\n            }\n          };\n\n          var isVelocity = Math.abs(velocity) < config.restSpeedThreshold;\n          var isDisplacement = config.stiffness === 0 || Math.abs(toValue - current) < config.restDisplacementThreshold;\n\n          if (zeta < 1) {\n            animation.current = underDampedPosition;\n            animation.velocity = underDampedVelocity;\n          } else {\n            animation.current = criticallyDampedPosition;\n            animation.velocity = criticallyDampedVelocity;\n          }\n\n          if (isOvershooting() || isVelocity && isDisplacement) {\n            if (config.stiffness !== 0) {\n              animation.velocity = 0;\n              animation.current = toValue;\n            }\n\n            return true;\n          }\n        }\n\n        function start(animation, value, now, previousAnimation) {\n          animation.current = value;\n\n          if (previousAnimation) {\n            animation.velocity = previousAnimation.velocity || animation.velocity || 0;\n            animation.lastTimestamp = previousAnimation.lastTimestamp || now;\n          } else {\n            animation.lastTimestamp = now;\n          }\n        }\n\n        return {\n          animation: spring,\n          start: start,\n          toValue: toValue,\n          velocity: config.velocity || 0,\n          current: toValue,\n          callback: callback\n        };\n      };\n\n      _f._closure = {\n        userConfig: userConfig,\n        toValue: toValue,\n        callback: callback\n      };\n      _f.asString = \"function _f(){const{userConfig,toValue,callback}=jsThis._closure;{var config={damping:10,mass:1,stiffness:100,overshootClamping:false,restDisplacementThreshold:0.001,restSpeedThreshold:0.001};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}function spring(animation,now){var toValue=animation.toValue,lastTimestamp=animation.lastTimestamp,current=animation.current,velocity=animation.velocity;var deltaTime=Math.min(now-lastTimestamp,64);animation.lastTimestamp=now;var c=config.damping;var m=config.mass;var k=config.stiffness;var v0=-velocity;var x0=toValue-current;var zeta=c/(2*Math.sqrt(k*m));var omega0=Math.sqrt(k/m);var omega1=omega0*Math.sqrt(1-Math.pow(zeta,2));var t=deltaTime/1000;var sin1=Math.sin(omega1*t);var cos1=Math.cos(omega1*t);var underDampedEnvelope=Math.exp(-zeta*omega0*t);var underDampedFrag1=underDampedEnvelope*(sin1*((v0+zeta*omega0*x0)/omega1)+x0*cos1);var underDampedPosition=toValue-underDampedFrag1;var underDampedVelocity=zeta*omega0*underDampedFrag1-underDampedEnvelope*(cos1*(v0+zeta*omega0*x0)-omega1*x0*sin1);var criticallyDampedEnvelope=Math.exp(-omega0*t);var criticallyDampedPosition=toValue-criticallyDampedEnvelope*(x0+(v0+omega0*x0)*t);var criticallyDampedVelocity=criticallyDampedEnvelope*(v0*(t*omega0-1)+t*x0*omega0*omega0);var isOvershooting=function isOvershooting(){if(config.overshootClamping&&config.stiffness!==0){return current<toValue?animation.current>toValue:animation.current<toValue;}else{return false;}};var isVelocity=Math.abs(velocity)<config.restSpeedThreshold;var isDisplacement=config.stiffness===0||Math.abs(toValue-current)<config.restDisplacementThreshold;if(zeta<1){animation.current=underDampedPosition;animation.velocity=underDampedVelocity;}else{animation.current=criticallyDampedPosition;animation.velocity=criticallyDampedVelocity;}if(isOvershooting()||isVelocity&&isDisplacement){if(config.stiffness!==0){animation.velocity=0;animation.current=toValue;}return true;}}function start(animation,value,now,previousAnimation){animation.current=value;if(previousAnimation){animation.velocity=previousAnimation.velocity||animation.velocity||0;animation.lastTimestamp=previousAnimation.lastTimestamp||now;}else{animation.lastTimestamp=now;}}return{animation:spring,start:start,toValue:toValue,velocity:config.velocity||0,current:toValue,callback:callback};}}\";\n      _f.__workletHash = 11791239759105;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }());\n  };\n\n  _f._closure = {\n    assertNumber: assertNumber,\n    defineAnimation: defineAnimation\n  };\n  _f.asString = \"function withSpring(toValue,userConfig,callback){const{assertNumber,defineAnimation}=jsThis._closure;{assertNumber(toValue,'withSpring');return defineAnimation(toValue,function(){var _f=function _f(){var config={damping:10,mass:1,stiffness:100,overshootClamping:false,restDisplacementThreshold:0.001,restSpeedThreshold:0.001};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}function spring(animation,now){var toValue=animation.toValue,lastTimestamp=animation.lastTimestamp,current=animation.current,velocity=animation.velocity;var deltaTime=Math.min(now-lastTimestamp,64);animation.lastTimestamp=now;var c=config.damping;var m=config.mass;var k=config.stiffness;var v0=-velocity;var x0=toValue-current;var zeta=c/(2*Math.sqrt(k*m));var omega0=Math.sqrt(k/m);var omega1=omega0*Math.sqrt(1-Math.pow(zeta,2));var t=deltaTime/1000;var sin1=Math.sin(omega1*t);var cos1=Math.cos(omega1*t);var underDampedEnvelope=Math.exp(-zeta*omega0*t);var underDampedFrag1=underDampedEnvelope*(sin1*((v0+zeta*omega0*x0)/omega1)+x0*cos1);var underDampedPosition=toValue-underDampedFrag1;var underDampedVelocity=zeta*omega0*underDampedFrag1-underDampedEnvelope*(cos1*(v0+zeta*omega0*x0)-omega1*x0*sin1);var criticallyDampedEnvelope=Math.exp(-omega0*t);var criticallyDampedPosition=toValue-criticallyDampedEnvelope*(x0+(v0+omega0*x0)*t);var criticallyDampedVelocity=criticallyDampedEnvelope*(v0*(t*omega0-1)+t*x0*omega0*omega0);var isOvershooting=function isOvershooting(){if(config.overshootClamping&&config.stiffness!==0){return current<toValue?animation.current>toValue:animation.current<toValue;}else{return false;}};var isVelocity=Math.abs(velocity)<config.restSpeedThreshold;var isDisplacement=config.stiffness===0||Math.abs(toValue-current)<config.restDisplacementThreshold;if(zeta<1){animation.current=underDampedPosition;animation.velocity=underDampedVelocity;}else{animation.current=criticallyDampedPosition;animation.velocity=criticallyDampedVelocity;}if(isOvershooting()||isVelocity&&isDisplacement){if(config.stiffness!==0){animation.velocity=0;animation.current=toValue;}return true;}}function start(animation,value,now,previousAnimation){animation.current=value;if(previousAnimation){animation.velocity=previousAnimation.velocity||animation.velocity||0;animation.lastTimestamp=previousAnimation.lastTimestamp||now;}else{animation.lastTimestamp=now;}}return{animation:spring,start:start,toValue:toValue,velocity:config.velocity||0,current:toValue,callback:callback};};_f._closure={userConfig:userConfig,toValue:toValue,callback:callback};_f.asString=\\\"function _f(){const{userConfig,toValue,callback}=jsThis._closure;{var config={damping:10,mass:1,stiffness:100,overshootClamping:false,restDisplacementThreshold:0.001,restSpeedThreshold:0.001};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}function spring(animation,now){var toValue=animation.toValue,lastTimestamp=animation.lastTimestamp,current=animation.current,velocity=animation.velocity;var deltaTime=Math.min(now-lastTimestamp,64);animation.lastTimestamp=now;var c=config.damping;var m=config.mass;var k=config.stiffness;var v0=-velocity;var x0=toValue-current;var zeta=c/(2*Math.sqrt(k*m));var omega0=Math.sqrt(k/m);var omega1=omega0*Math.sqrt(1-Math.pow(zeta,2));var t=deltaTime/1000;var sin1=Math.sin(omega1*t);var cos1=Math.cos(omega1*t);var underDampedEnvelope=Math.exp(-zeta*omega0*t);var underDampedFrag1=underDampedEnvelope*(sin1*((v0+zeta*omega0*x0)/omega1)+x0*cos1);var underDampedPosition=toValue-underDampedFrag1;var underDampedVelocity=zeta*omega0*underDampedFrag1-underDampedEnvelope*(cos1*(v0+zeta*omega0*x0)-omega1*x0*sin1);var criticallyDampedEnvelope=Math.exp(-omega0*t);var criticallyDampedPosition=toValue-criticallyDampedEnvelope*(x0+(v0+omega0*x0)*t);var criticallyDampedVelocity=criticallyDampedEnvelope*(v0*(t*omega0-1)+t*x0*omega0*omega0);var isOvershooting=function isOvershooting(){if(config.overshootClamping&&config.stiffness!==0){return current<toValue?animation.current>toValue:animation.current<toValue;}else{return false;}};var isVelocity=Math.abs(velocity)<config.restSpeedThreshold;var isDisplacement=config.stiffness===0||Math.abs(toValue-current)<config.restDisplacementThreshold;if(zeta<1){animation.current=underDampedPosition;animation.velocity=underDampedVelocity;}else{animation.current=criticallyDampedPosition;animation.velocity=criticallyDampedVelocity;}if(isOvershooting()||isVelocity&&isDisplacement){if(config.stiffness!==0){animation.velocity=0;animation.current=toValue;}return true;}}function start(animation,value,now,previousAnimation){animation.current=value;if(previousAnimation){animation.velocity=previousAnimation.velocity||animation.velocity||0;animation.lastTimestamp=previousAnimation.lastTimestamp||now;}else{animation.lastTimestamp=now;}}return{animation:spring,start:start,toValue:toValue,velocity:config.velocity||0,current:toValue,callback:callback};}}\\\";_f.__workletHash=11791239759105;global.__reanimatedWorkletInit(_f);return _f;}());}}\";\n  _f.__workletHash = 11601228126680;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.withSpring = withSpring;\n\nvar withDecay = function () {\n  var _f = function _f(userConfig, callback) {\n    return defineAnimation(0, function () {\n      var _f = function _f() {\n        var config = {\n          deceleration: 0.998\n        };\n\n        if (userConfig) {\n          Object.keys(userConfig).forEach(function (key) {\n            return config[key] = userConfig[key];\n          });\n        }\n\n        var VELOCITY_EPS = 5;\n\n        function decay(animation, now) {\n          var lastTimestamp = animation.lastTimestamp,\n              initialVelocity = animation.initialVelocity,\n              current = animation.current,\n              velocity = animation.velocity;\n          var deltaTime = Math.min(now - lastTimestamp, 64);\n          animation.lastTimestamp = now;\n          var kv = Math.pow(config.deceleration, deltaTime);\n          var kx = config.deceleration * (1 - kv) / (1 - config.deceleration);\n          var v0 = velocity / 1000;\n          var v = v0 * kv * 1000;\n          var x = current + v0 * kx;\n          animation.current = x;\n          animation.velocity = v;\n          var toValueIsReached = null;\n\n          if (Array.isArray(config.clamp)) {\n            if (initialVelocity < 0 && animation.current <= config.clamp[0]) {\n              toValueIsReached = config.clamp[0];\n            } else if (initialVelocity > 0 && animation.current >= config.clamp[1]) {\n              toValueIsReached = config.clamp[1];\n            }\n          }\n\n          if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {\n            if (toValueIsReached !== null) {\n              animation.current = toValueIsReached;\n            }\n\n            return true;\n          }\n        }\n\n        function start(animation, value, now) {\n          animation.current = value;\n          animation.lastTimestamp = now;\n          animation.initialVelocity = config.velocity;\n        }\n\n        return {\n          animation: decay,\n          start: start,\n          velocity: config.velocity || 0,\n          callback: callback\n        };\n      };\n\n      _f._closure = {\n        userConfig: userConfig,\n        callback: callback\n      };\n      _f.asString = \"function _f(){const{userConfig,callback}=jsThis._closure;{var config={deceleration:0.998};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}var VELOCITY_EPS=5;function decay(animation,now){var lastTimestamp=animation.lastTimestamp,initialVelocity=animation.initialVelocity,current=animation.current,velocity=animation.velocity;var deltaTime=Math.min(now-lastTimestamp,64);animation.lastTimestamp=now;var kv=Math.pow(config.deceleration,deltaTime);var kx=config.deceleration*(1-kv)/(1-config.deceleration);var v0=velocity/1000;var v=v0*kv*1000;var x=current+v0*kx;animation.current=x;animation.velocity=v;var toValueIsReached=null;if(Array.isArray(config.clamp)){if(initialVelocity<0&&animation.current<=config.clamp[0]){toValueIsReached=config.clamp[0];}else if(initialVelocity>0&&animation.current>=config.clamp[1]){toValueIsReached=config.clamp[1];}}if(Math.abs(v)<VELOCITY_EPS||toValueIsReached!==null){if(toValueIsReached!==null){animation.current=toValueIsReached;}return true;}}function start(animation,value,now){animation.current=value;animation.lastTimestamp=now;animation.initialVelocity=config.velocity;}return{animation:decay,start:start,velocity:config.velocity||0,callback:callback};}}\";\n      _f.__workletHash = 4584511784866;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }());\n  };\n\n  _f._closure = {\n    defineAnimation: defineAnimation\n  };\n  _f.asString = \"function withDecay(userConfig,callback){const{defineAnimation}=jsThis._closure;{return defineAnimation(0,function(){var _f=function _f(){var config={deceleration:0.998};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}var VELOCITY_EPS=5;function decay(animation,now){var lastTimestamp=animation.lastTimestamp,initialVelocity=animation.initialVelocity,current=animation.current,velocity=animation.velocity;var deltaTime=Math.min(now-lastTimestamp,64);animation.lastTimestamp=now;var kv=Math.pow(config.deceleration,deltaTime);var kx=config.deceleration*(1-kv)/(1-config.deceleration);var v0=velocity/1000;var v=v0*kv*1000;var x=current+v0*kx;animation.current=x;animation.velocity=v;var toValueIsReached=null;if(Array.isArray(config.clamp)){if(initialVelocity<0&&animation.current<=config.clamp[0]){toValueIsReached=config.clamp[0];}else if(initialVelocity>0&&animation.current>=config.clamp[1]){toValueIsReached=config.clamp[1];}}if(Math.abs(v)<VELOCITY_EPS||toValueIsReached!==null){if(toValueIsReached!==null){animation.current=toValueIsReached;}return true;}}function start(animation,value,now){animation.current=value;animation.lastTimestamp=now;animation.initialVelocity=config.velocity;}return{animation:decay,start:start,velocity:config.velocity||0,callback:callback};};_f._closure={userConfig:userConfig,callback:callback};_f.asString=\\\"function _f(){const{userConfig,callback}=jsThis._closure;{var config={deceleration:0.998};if(userConfig){Object.keys(userConfig).forEach(function(key){return config[key]=userConfig[key];});}var VELOCITY_EPS=5;function decay(animation,now){var lastTimestamp=animation.lastTimestamp,initialVelocity=animation.initialVelocity,current=animation.current,velocity=animation.velocity;var deltaTime=Math.min(now-lastTimestamp,64);animation.lastTimestamp=now;var kv=Math.pow(config.deceleration,deltaTime);var kx=config.deceleration*(1-kv)/(1-config.deceleration);var v0=velocity/1000;var v=v0*kv*1000;var x=current+v0*kx;animation.current=x;animation.velocity=v;var toValueIsReached=null;if(Array.isArray(config.clamp)){if(initialVelocity<0&&animation.current<=config.clamp[0]){toValueIsReached=config.clamp[0];}else if(initialVelocity>0&&animation.current>=config.clamp[1]){toValueIsReached=config.clamp[1];}}if(Math.abs(v)<VELOCITY_EPS||toValueIsReached!==null){if(toValueIsReached!==null){animation.current=toValueIsReached;}return true;}}function start(animation,value,now){animation.current=value;animation.lastTimestamp=now;animation.initialVelocity=config.velocity;}return{animation:decay,start:start,velocity:config.velocity||0,callback:callback};}}\\\";_f.__workletHash=4584511784866;global.__reanimatedWorkletInit(_f);return _f;}());}}\";\n  _f.__workletHash = 6366370878223;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.withDecay = withDecay;\n\nvar delay = function () {\n  var _f = function _f(delayMs, _nextAnimation) {\n    return defineAnimation(_nextAnimation, function () {\n      var _f = function _f() {\n        var nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n        function delay(animation, now) {\n          var startTime = animation.startTime,\n              started = animation.started,\n              previousAnimation = animation.previousAnimation;\n\n          if (now - startTime > delayMs) {\n            if (!started) {\n              nextAnimation.start(nextAnimation, animation.current, now, previousAnimation);\n              animation.previousAnimation = null;\n              animation.started = true;\n            }\n\n            var finished = nextAnimation.animation(nextAnimation, now);\n            animation.current = nextAnimation.current;\n            return finished;\n          } else if (previousAnimation) {\n            var _finished = previousAnimation.animation(previousAnimation, now);\n\n            animation.current = previousAnimation.current;\n\n            if (_finished) {\n              animation.previousAnimation = null;\n            }\n          }\n\n          return false;\n        }\n\n        function start(animation, value, now, previousAnimation) {\n          animation.startTime = now;\n          animation.started = false;\n          animation.current = value;\n          animation.previousAnimation = previousAnimation;\n        }\n\n        var callback = function callback(finished) {\n          if (nextAnimation.callback) {\n            nextAnimation.callback(finished);\n          }\n        };\n\n        return {\n          animation: delay,\n          start: start,\n          current: nextAnimation.current,\n          callback: callback\n        };\n      };\n\n      _f._closure = {\n        _nextAnimation: _nextAnimation,\n        delayMs: delayMs\n      };\n      _f.asString = \"function _f(){const{_nextAnimation,delayMs}=jsThis._closure;{var nextAnimation=typeof _nextAnimation==='function'?_nextAnimation():_nextAnimation;function delay(animation,now){var startTime=animation.startTime,started=animation.started,previousAnimation=animation.previousAnimation;if(now-startTime>delayMs){if(!started){nextAnimation.start(nextAnimation,animation.current,now,previousAnimation);animation.previousAnimation=null;animation.started=true;}var finished=nextAnimation.animation(nextAnimation,now);animation.current=nextAnimation.current;return finished;}else if(previousAnimation){var _finished=previousAnimation.animation(previousAnimation,now);animation.current=previousAnimation.current;if(_finished){animation.previousAnimation=null;}}return false;}function start(animation,value,now,previousAnimation){animation.startTime=now;animation.started=false;animation.current=value;animation.previousAnimation=previousAnimation;}var callback=function callback(finished){if(nextAnimation.callback){nextAnimation.callback(finished);}};return{animation:delay,start:start,current:nextAnimation.current,callback:callback};}}\";\n      _f.__workletHash = 10720760093965;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }());\n  };\n\n  _f._closure = {\n    defineAnimation: defineAnimation\n  };\n  _f.asString = \"function delay(delayMs,_nextAnimation){const{defineAnimation}=jsThis._closure;{return defineAnimation(_nextAnimation,function(){var _f=function _f(){var nextAnimation=typeof _nextAnimation==='function'?_nextAnimation():_nextAnimation;function delay(animation,now){var startTime=animation.startTime,started=animation.started,previousAnimation=animation.previousAnimation;if(now-startTime>delayMs){if(!started){nextAnimation.start(nextAnimation,animation.current,now,previousAnimation);animation.previousAnimation=null;animation.started=true;}var finished=nextAnimation.animation(nextAnimation,now);animation.current=nextAnimation.current;return finished;}else if(previousAnimation){var _finished=previousAnimation.animation(previousAnimation,now);animation.current=previousAnimation.current;if(_finished){animation.previousAnimation=null;}}return false;}function start(animation,value,now,previousAnimation){animation.startTime=now;animation.started=false;animation.current=value;animation.previousAnimation=previousAnimation;}var callback=function callback(finished){if(nextAnimation.callback){nextAnimation.callback(finished);}};return{animation:delay,start:start,current:nextAnimation.current,callback:callback};};_f._closure={_nextAnimation:_nextAnimation,delayMs:delayMs};_f.asString=\\\"function _f(){const{_nextAnimation,delayMs}=jsThis._closure;{var nextAnimation=typeof _nextAnimation==='function'?_nextAnimation():_nextAnimation;function delay(animation,now){var startTime=animation.startTime,started=animation.started,previousAnimation=animation.previousAnimation;if(now-startTime>delayMs){if(!started){nextAnimation.start(nextAnimation,animation.current,now,previousAnimation);animation.previousAnimation=null;animation.started=true;}var finished=nextAnimation.animation(nextAnimation,now);animation.current=nextAnimation.current;return finished;}else if(previousAnimation){var _finished=previousAnimation.animation(previousAnimation,now);animation.current=previousAnimation.current;if(_finished){animation.previousAnimation=null;}}return false;}function start(animation,value,now,previousAnimation){animation.startTime=now;animation.started=false;animation.current=value;animation.previousAnimation=previousAnimation;}var callback=function callback(finished){if(nextAnimation.callback){nextAnimation.callback(finished);}};return{animation:delay,start:start,current:nextAnimation.current,callback:callback};}}\\\";_f.__workletHash=10720760093965;global.__reanimatedWorkletInit(_f);return _f;}());}}\";\n  _f.__workletHash = 5924895091842;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.delay = delay;\n\nvar sequence = function () {\n  var _f = function _f() {\n    for (var _len = arguments.length, _animations = new Array(_len), _key = 0; _key < _len; _key++) {\n      _animations[_key] = arguments[_key];\n    }\n\n    return defineAnimation(_animations[0], function () {\n      var _f = function _f() {\n        var animations = _animations.map(function (a) {\n          var result = typeof a === 'function' ? a() : a;\n          result.finished = false;\n          return result;\n        });\n\n        var firstAnimation = animations[0];\n\n        var callback = function callback(finished) {\n          if (finished) {\n            return;\n          }\n\n          animations.forEach(function (animation) {\n            if (typeof animation.callback === 'function' && !animation.finished) {\n              animation.callback(finished);\n            }\n          });\n        };\n\n        function sequence(animation, now) {\n          var currentAnim = animations[animation.animationIndex];\n          var finished = currentAnim.animation(currentAnim, now);\n          animation.current = currentAnim.current;\n\n          if (finished) {\n            if (currentAnim.callback) {\n              currentAnim.callback(true);\n            }\n\n            currentAnim.finished = true;\n            animation.animationIndex += 1;\n\n            if (animation.animationIndex < animations.length) {\n              var nextAnim = animations[animation.animationIndex];\n              nextAnim.start(nextAnim, currentAnim.current, now, currentAnim);\n              return false;\n            }\n\n            return true;\n          }\n\n          return false;\n        }\n\n        function start(animation, value, now, previousAnimation) {\n          animation.animationIndex = 0;\n          firstAnimation.start(firstAnimation, value, now, previousAnimation);\n        }\n\n        return {\n          animation: sequence,\n          start: start,\n          animationIndex: 0,\n          current: firstAnimation.current,\n          callback: callback\n        };\n      };\n\n      _f._closure = {\n        _animations: _animations\n      };\n      _f.asString = \"function _f(){const{_animations}=jsThis._closure;{var animations=_animations.map(function(a){var result=typeof a==='function'?a():a;result.finished=false;return result;});var firstAnimation=animations[0];var callback=function callback(finished){if(finished){return;}animations.forEach(function(animation){if(typeof animation.callback==='function'&&!animation.finished){animation.callback(finished);}});};function sequence(animation,now){var currentAnim=animations[animation.animationIndex];var finished=currentAnim.animation(currentAnim,now);animation.current=currentAnim.current;if(finished){if(currentAnim.callback){currentAnim.callback(true);}currentAnim.finished=true;animation.animationIndex+=1;if(animation.animationIndex<animations.length){var nextAnim=animations[animation.animationIndex];nextAnim.start(nextAnim,currentAnim.current,now,currentAnim);return false;}return true;}return false;}function start(animation,value,now,previousAnimation){animation.animationIndex=0;firstAnimation.start(firstAnimation,value,now,previousAnimation);}return{animation:sequence,start:start,animationIndex:0,current:firstAnimation.current,callback:callback};}}\";\n      _f.__workletHash = 4904851272151;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }());\n  };\n\n  _f._closure = {\n    defineAnimation: defineAnimation\n  };\n  _f.asString = \"function sequence(){const{defineAnimation}=jsThis._closure;{for(var _len=arguments.length,_animations=new Array(_len),_key=0;_key<_len;_key++){_animations[_key]=arguments[_key];}return defineAnimation(_animations[0],function(){var _f=function _f(){var animations=_animations.map(function(a){var result=typeof a==='function'?a():a;result.finished=false;return result;});var firstAnimation=animations[0];var callback=function callback(finished){if(finished){return;}animations.forEach(function(animation){if(typeof animation.callback==='function'&&!animation.finished){animation.callback(finished);}});};function sequence(animation,now){var currentAnim=animations[animation.animationIndex];var finished=currentAnim.animation(currentAnim,now);animation.current=currentAnim.current;if(finished){if(currentAnim.callback){currentAnim.callback(true);}currentAnim.finished=true;animation.animationIndex+=1;if(animation.animationIndex<animations.length){var nextAnim=animations[animation.animationIndex];nextAnim.start(nextAnim,currentAnim.current,now,currentAnim);return false;}return true;}return false;}function start(animation,value,now,previousAnimation){animation.animationIndex=0;firstAnimation.start(firstAnimation,value,now,previousAnimation);}return{animation:sequence,start:start,animationIndex:0,current:firstAnimation.current,callback:callback};};_f._closure={_animations:_animations};_f.asString=\\\"function _f(){const{_animations}=jsThis._closure;{var animations=_animations.map(function(a){var result=typeof a==='function'?a():a;result.finished=false;return result;});var firstAnimation=animations[0];var callback=function callback(finished){if(finished){return;}animations.forEach(function(animation){if(typeof animation.callback==='function'&&!animation.finished){animation.callback(finished);}});};function sequence(animation,now){var currentAnim=animations[animation.animationIndex];var finished=currentAnim.animation(currentAnim,now);animation.current=currentAnim.current;if(finished){if(currentAnim.callback){currentAnim.callback(true);}currentAnim.finished=true;animation.animationIndex+=1;if(animation.animationIndex<animations.length){var nextAnim=animations[animation.animationIndex];nextAnim.start(nextAnim,currentAnim.current,now,currentAnim);return false;}return true;}return false;}function start(animation,value,now,previousAnimation){animation.animationIndex=0;firstAnimation.start(firstAnimation,value,now,previousAnimation);}return{animation:sequence,start:start,animationIndex:0,current:firstAnimation.current,callback:callback};}}\\\";_f.__workletHash=4904851272151;global.__reanimatedWorkletInit(_f);return _f;}());}}\";\n  _f.__workletHash = 144505731420;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.sequence = sequence;\n\nvar repeat = function () {\n  var _f = function _f(_nextAnimation) {\n    var numberOfReps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;\n    var reverse = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var callback = arguments.length > 3 ? arguments[3] : undefined;\n    return defineAnimation(_nextAnimation, function () {\n      var _f = function _f() {\n        var nextAnimation = typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n        function repeat(animation, now) {\n          var finished = nextAnimation.animation(nextAnimation, now);\n          animation.current = nextAnimation.current;\n\n          if (finished) {\n            animation.reps += 1;\n\n            if (nextAnimation.callback) {\n              nextAnimation.callback(true, animation.current);\n            }\n\n            if (numberOfReps > 0 && animation.reps >= numberOfReps) {\n              return true;\n            }\n\n            var startValue = reverse ? nextAnimation.current : animation.startValue;\n\n            if (reverse) {\n              nextAnimation.toValue = animation.startValue;\n              animation.startValue = startValue;\n            }\n\n            nextAnimation.start(nextAnimation, startValue, now, nextAnimation);\n            return false;\n          }\n\n          return false;\n        }\n\n        var repCallback = function repCallback(finished) {\n          if (callback) {\n            callback(finished);\n          }\n\n          if (!finished && nextAnimation.callback) {\n            nextAnimation.callback(false);\n          }\n        };\n\n        function start(animation, value, now, previousAnimation) {\n          animation.startValue = value;\n          animation.reps = 0;\n          nextAnimation.start(nextAnimation, value, now, previousAnimation);\n        }\n\n        return {\n          animation: repeat,\n          start: start,\n          reps: 0,\n          current: nextAnimation.current,\n          callback: repCallback\n        };\n      };\n\n      _f._closure = {\n        _nextAnimation: _nextAnimation,\n        numberOfReps: numberOfReps,\n        reverse: reverse,\n        callback: callback\n      };\n      _f.asString = \"function _f(){const{_nextAnimation,numberOfReps,reverse,callback}=jsThis._closure;{var nextAnimation=typeof _nextAnimation==='function'?_nextAnimation():_nextAnimation;function repeat(animation,now){var finished=nextAnimation.animation(nextAnimation,now);animation.current=nextAnimation.current;if(finished){animation.reps+=1;if(nextAnimation.callback){nextAnimation.callback(true,animation.current);}if(numberOfReps>0&&animation.reps>=numberOfReps){return true;}var startValue=reverse?nextAnimation.current:animation.startValue;if(reverse){nextAnimation.toValue=animation.startValue;animation.startValue=startValue;}nextAnimation.start(nextAnimation,startValue,now,nextAnimation);return false;}return false;}var repCallback=function repCallback(finished){if(callback){callback(finished);}if(!finished&&nextAnimation.callback){nextAnimation.callback(false);}};function start(animation,value,now,previousAnimation){animation.startValue=value;animation.reps=0;nextAnimation.start(nextAnimation,value,now,previousAnimation);}return{animation:repeat,start:start,reps:0,current:nextAnimation.current,callback:repCallback};}}\";\n      _f.__workletHash = 6051133556031;\n\n      global.__reanimatedWorkletInit(_f);\n\n      return _f;\n    }());\n  };\n\n  _f._closure = {\n    defineAnimation: defineAnimation\n  };\n  _f.asString = \"function repeat(_nextAnimation){const{defineAnimation}=jsThis._closure;{var numberOfReps=arguments.length>1&&arguments[1]!==undefined?arguments[1]:2;var reverse=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;var callback=arguments.length>3?arguments[3]:undefined;return defineAnimation(_nextAnimation,function(){var _f=function _f(){var nextAnimation=typeof _nextAnimation==='function'?_nextAnimation():_nextAnimation;function repeat(animation,now){var finished=nextAnimation.animation(nextAnimation,now);animation.current=nextAnimation.current;if(finished){animation.reps+=1;if(nextAnimation.callback){nextAnimation.callback(true,animation.current);}if(numberOfReps>0&&animation.reps>=numberOfReps){return true;}var startValue=reverse?nextAnimation.current:animation.startValue;if(reverse){nextAnimation.toValue=animation.startValue;animation.startValue=startValue;}nextAnimation.start(nextAnimation,startValue,now,nextAnimation);return false;}return false;}var repCallback=function repCallback(finished){if(callback){callback(finished);}if(!finished&&nextAnimation.callback){nextAnimation.callback(false);}};function start(animation,value,now,previousAnimation){animation.startValue=value;animation.reps=0;nextAnimation.start(nextAnimation,value,now,previousAnimation);}return{animation:repeat,start:start,reps:0,current:nextAnimation.current,callback:repCallback};};_f._closure={_nextAnimation:_nextAnimation,numberOfReps:numberOfReps,reverse:reverse,callback:callback};_f.asString=\\\"function _f(){const{_nextAnimation,numberOfReps,reverse,callback}=jsThis._closure;{var nextAnimation=typeof _nextAnimation==='function'?_nextAnimation():_nextAnimation;function repeat(animation,now){var finished=nextAnimation.animation(nextAnimation,now);animation.current=nextAnimation.current;if(finished){animation.reps+=1;if(nextAnimation.callback){nextAnimation.callback(true,animation.current);}if(numberOfReps>0&&animation.reps>=numberOfReps){return true;}var startValue=reverse?nextAnimation.current:animation.startValue;if(reverse){nextAnimation.toValue=animation.startValue;animation.startValue=startValue;}nextAnimation.start(nextAnimation,startValue,now,nextAnimation);return false;}return false;}var repCallback=function repCallback(finished){if(callback){callback(finished);}if(!finished&&nextAnimation.callback){nextAnimation.callback(false);}};function start(animation,value,now,previousAnimation){animation.startValue=value;animation.reps=0;nextAnimation.start(nextAnimation,value,now,previousAnimation);}return{animation:repeat,start:start,reps:0,current:nextAnimation.current,callback:repCallback};}}\\\";_f.__workletHash=6051133556031;global.__reanimatedWorkletInit(_f);return _f;}());}}\";\n  _f.__workletHash = 2520084871876;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.repeat = repeat;\n\nvar loop = function () {\n  var _f = function _f(nextAnimation) {\n    var numberOfLoops = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    console.warn('Method `loop` is deprecated. Please use `repeat` instead');\n    return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);\n  };\n\n  _f._closure = {\n    console: {\n      warn: console.warn\n    },\n    repeat: repeat\n  };\n  _f.asString = \"function loop(nextAnimation){const{console,repeat}=jsThis._closure;{var numberOfLoops=arguments.length>1&&arguments[1]!==undefined?arguments[1]:1;console.warn('Method `loop` is deprecated. Please use `repeat` instead');return repeat(nextAnimation,Math.round(numberOfLoops*2),true);}}\";\n  _f.__workletHash = 1278074625726;\n\n  global.__reanimatedWorkletInit(_f);\n\n  return _f;\n}();\n\nexports.loop = loop;","map":{"version":3,"sources":["D:/Programming/React Native/drinkUp/node_modules/react-native-reanimated/src/reanimated2/animations.js"],"names":["IN_STYLE_UPDATER","assertNumber","value","callerName","valueType","error","Error","initialUpdaterRun","updater","result","defineAnimation","starting","factory","_WORKLET","NativeReanimated","native","cancelAnimation","sharedValue","withTiming","toValue","userConfig","callback","config","duration","easing","Easing","inOut","quad","Object","keys","forEach","key","timing","animation","now","progress","startTime","current","runtime","newProgress","dist","start","previousAnimation","type","withSpring","damping","mass","stiffness","overshootClamping","restDisplacementThreshold","restSpeedThreshold","spring","lastTimestamp","velocity","deltaTime","Math","min","c","m","k","v0","x0","zeta","sqrt","omega0","omega1","t","sin1","sin","cos1","cos","underDampedEnvelope","exp","underDampedFrag1","underDampedPosition","underDampedVelocity","criticallyDampedEnvelope","criticallyDampedPosition","criticallyDampedVelocity","isOvershooting","isVelocity","abs","isDisplacement","withDecay","deceleration","VELOCITY_EPS","decay","initialVelocity","kv","pow","kx","v","x","toValueIsReached","Array","isArray","clamp","delay","delayMs","_nextAnimation","nextAnimation","started","finished","sequence","_animations","animations","map","a","firstAnimation","currentAnim","animationIndex","length","nextAnim","repeat","numberOfReps","reverse","reps","startValue","repCallback","loop","numberOfLoops","console","warn","round"],"mappings":"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","sourcesContent":["/* global _WORKLET */\nimport { Easing } from './Easing';\nimport NativeReanimated from './NativeReanimated';\n\nlet IN_STYLE_UPDATER = false;\n\nconst assertNumber = (value, callerName) => {\n  'worklet'\n  const valueType = typeof value;\n  if (valueType !== 'number') {\n    let error = `invalid type of toValue passed to ${callerName}, expected \\`number\\`, got \\`${valueType}\\``;\n    if (valueType === 'object') {\n      error += ', maybe you forgot to add `.value`?';\n    }\n    throw new Error(error);\n  }\n};\n\nexport function initialUpdaterRun(updater) {\n  IN_STYLE_UPDATER = true;\n  const result = updater();\n  IN_STYLE_UPDATER = false;\n  return result;\n}\n\nfunction defineAnimation(starting, factory) {\n  'worklet';\n  if (IN_STYLE_UPDATER) {\n    return starting;\n  }\n  if (_WORKLET || !NativeReanimated.native) {\n    return factory();\n  }\n  return factory;\n}\n\nexport function cancelAnimation(sharedValue) {\n  'worklet';\n  // setting the current value cancels the animation if one is currently running\n  sharedValue.value = sharedValue.value; // eslint-disable-line no-self-assign\n}\n\nexport function withTiming(toValue, userConfig, callback) {\n  'worklet';\n  // check toValue\n  assertNumber(toValue, 'withTiming');\n\n  return defineAnimation(toValue, () => {\n    'worklet';\n    const config = {\n      duration: 300,\n      easing: Easing.inOut(Easing.quad),\n    };\n    if (userConfig) {\n      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n    }\n\n    function timing(animation, now) {\n      const { toValue, progress, startTime, current } = animation;\n\n      const runtime = now - startTime;\n\n      if (runtime >= config.duration) {\n        // reset startTime to avoid reusing finished animation config in `start` method\n        animation.startTime = 0;\n        animation.current = toValue;\n        return true;\n      }\n\n      const newProgress = config.easing(runtime / config.duration);\n\n      const dist =\n        ((toValue - current) * (newProgress - progress)) / (1 - progress);\n      animation.current += dist;\n      animation.progress = newProgress;\n      return false;\n    }\n\n    function start(animation, value, now, previousAnimation) {\n      if (\n        previousAnimation &&\n        previousAnimation.type === 'timing' &&\n        previousAnimation.toValue === toValue &&\n        previousAnimation.startTime\n      ) {\n        // to maintain continuity of timing animations we check if we are starting\n        // new timing over the old one with the same parameters. If so, we want\n        // to copy animation timeline properties\n        animation.startTime = previousAnimation.startTime;\n        animation.progress = previousAnimation.progress;\n      } else {\n        animation.startTime = now;\n        animation.progress = 0;\n      }\n      animation.current = value;\n    }\n\n    return {\n      type: 'timing',\n      animation: timing,\n      start,\n      progress: 0,\n      toValue,\n      current: toValue,\n      callback,\n    };\n  });\n}\n\nexport function withSpring(toValue, userConfig, callback) {\n  'worklet';\n  // check toValue\n  assertNumber(toValue, 'withSpring');\n\n  return defineAnimation(toValue, () => {\n    'worklet';\n\n    // TODO: figure out why we can't use spread or Object.assign here\n    // when user config is \"frozen object\" we can't enumerate it (perhaps\n    // something is wrong with the object prototype).\n    const config = {\n      damping: 10,\n      mass: 1,\n      stiffness: 100,\n      overshootClamping: false,\n      restDisplacementThreshold: 0.001,\n      restSpeedThreshold: 0.001,\n    };\n    if (userConfig) {\n      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n    }\n\n    function spring(animation, now) {\n      const { toValue, lastTimestamp, current, velocity } = animation;\n\n      const deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n\n      const c = config.damping;\n      const m = config.mass;\n      const k = config.stiffness;\n\n      const v0 = -velocity;\n      const x0 = toValue - current;\n\n      const zeta = c / (2 * Math.sqrt(k * m)); // damping ratio\n      const omega0 = Math.sqrt(k / m); // undamped angular frequency of the oscillator (rad/ms)\n      const omega1 = omega0 * Math.sqrt(1 - zeta ** 2); // exponential decay\n\n      const t = deltaTime / 1000;\n\n      const sin1 = Math.sin(omega1 * t);\n      const cos1 = Math.cos(omega1 * t);\n\n      // under damped\n      const underDampedEnvelope = Math.exp(-zeta * omega0 * t);\n      const underDampedFrag1 =\n        underDampedEnvelope *\n        (sin1 * ((v0 + zeta * omega0 * x0) / omega1) + x0 * cos1);\n\n      const underDampedPosition = toValue - underDampedFrag1;\n      // This looks crazy -- it's actually just the derivative of the oscillation function\n      const underDampedVelocity =\n        zeta * omega0 * underDampedFrag1 -\n        underDampedEnvelope *\n          (cos1 * (v0 + zeta * omega0 * x0) - omega1 * x0 * sin1);\n\n      // critically damped\n      const criticallyDampedEnvelope = Math.exp(-omega0 * t);\n      const criticallyDampedPosition =\n        toValue - criticallyDampedEnvelope * (x0 + (v0 + omega0 * x0) * t);\n\n      const criticallyDampedVelocity =\n        criticallyDampedEnvelope *\n        (v0 * (t * omega0 - 1) + t * x0 * omega0 * omega0);\n\n      const isOvershooting = () => {\n        if (config.overshootClamping && config.stiffness !== 0) {\n          return current < toValue\n            ? animation.current > toValue\n            : animation.current < toValue;\n        } else {\n          return false;\n        }\n      };\n\n      const isVelocity = Math.abs(velocity) < config.restSpeedThreshold;\n      const isDisplacement =\n        config.stiffness === 0 ||\n        Math.abs(toValue - current) < config.restDisplacementThreshold;\n\n      if (zeta < 1) {\n        animation.current = underDampedPosition;\n        animation.velocity = underDampedVelocity;\n      } else {\n        animation.current = criticallyDampedPosition;\n        animation.velocity = criticallyDampedVelocity;\n      }\n\n      if (isOvershooting() || (isVelocity && isDisplacement)) {\n        if (config.stiffness !== 0) {\n          animation.velocity = 0;\n          animation.current = toValue;\n        }\n        return true;\n      }\n    }\n\n    function start(animation, value, now, previousAnimation) {\n      animation.current = value;\n      if (previousAnimation) {\n        animation.velocity =\n          previousAnimation.velocity || animation.velocity || 0;\n        animation.lastTimestamp = previousAnimation.lastTimestamp || now;\n      } else {\n        animation.lastTimestamp = now;\n      }\n    }\n\n    return {\n      animation: spring,\n      start,\n      toValue,\n      velocity: config.velocity || 0,\n      current: toValue,\n      callback,\n    };\n  });\n}\n\nexport function withDecay(userConfig, callback) {\n  'worklet';\n  return defineAnimation(0, () => {\n    'worklet';\n    const config = {\n      deceleration: 0.998,\n    };\n    if (userConfig) {\n      Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n    }\n\n    const VELOCITY_EPS = 5;\n\n    function decay(animation, now) {\n      const { lastTimestamp, initialVelocity, current, velocity } = animation;\n\n      const deltaTime = Math.min(now - lastTimestamp, 64);\n      animation.lastTimestamp = now;\n\n      const kv = Math.pow(config.deceleration, deltaTime);\n      const kx = (config.deceleration * (1 - kv)) / (1 - config.deceleration);\n\n      const v0 = velocity / 1000;\n      const v = v0 * kv * 1000;\n      const x = current + v0 * kx;\n\n      animation.current = x;\n      animation.velocity = v;\n\n      let toValueIsReached = null;\n\n      if (Array.isArray(config.clamp)) {\n        if (initialVelocity < 0 && animation.current <= config.clamp[0]) {\n          toValueIsReached = config.clamp[0];\n        } else if (\n          initialVelocity > 0 &&\n          animation.current >= config.clamp[1]\n        ) {\n          toValueIsReached = config.clamp[1];\n        }\n      }\n\n      if (Math.abs(v) < VELOCITY_EPS || toValueIsReached !== null) {\n        if (toValueIsReached !== null) {\n          animation.current = toValueIsReached;\n        }\n\n        return true;\n      }\n    }\n\n    function start(animation, value, now) {\n      animation.current = value;\n      animation.lastTimestamp = now;\n      animation.initialVelocity = config.velocity;\n    }\n\n    return {\n      animation: decay,\n      start,\n      velocity: config.velocity || 0,\n      callback,\n    };\n  });\n}\n\nexport function delay(delayMs, _nextAnimation) {\n  'worklet';\n  return defineAnimation(_nextAnimation, () => {\n    'worklet';\n\n    const nextAnimation =\n      typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function delay(animation, now) {\n      const { startTime, started, previousAnimation } = animation;\n\n      if (now - startTime > delayMs) {\n        if (!started) {\n          nextAnimation.start(\n            nextAnimation,\n            animation.current,\n            now,\n            previousAnimation\n          );\n          animation.previousAnimation = null;\n          animation.started = true;\n        }\n        const finished = nextAnimation.animation(nextAnimation, now);\n        animation.current = nextAnimation.current;\n        return finished;\n      } else if (previousAnimation) {\n        const finished = previousAnimation.animation(previousAnimation, now);\n        animation.current = previousAnimation.current;\n        if (finished) {\n          animation.previousAnimation = null;\n        }\n      }\n      return false;\n    }\n\n    function start(animation, value, now, previousAnimation) {\n      animation.startTime = now;\n      animation.started = false;\n      animation.current = value;\n      animation.previousAnimation = previousAnimation;\n    }\n\n    const callback = (finished) => {\n      if (nextAnimation.callback) {\n        nextAnimation.callback(finished);\n      }\n    };\n\n    return {\n      animation: delay,\n      start,\n      current: nextAnimation.current,\n      callback,\n    };\n  });\n}\n\nexport function sequence(..._animations) {\n  'worklet';\n  return defineAnimation(_animations[0], () => {\n    'worklet';\n    const animations = _animations.map((a) => {\n      const result = typeof a === 'function' ? a() : a;\n      result.finished = false;\n      return result;\n    });\n    const firstAnimation = animations[0];\n\n    const callback = (finished) => {\n      if (finished) {\n        // we want to call the callback after every single animation\n        // not after all of them\n        return;\n      }\n      // this is going to be called only if sequence has been cancelled\n      animations.forEach((animation) => {\n        if (typeof animation.callback === 'function' && !animation.finished) {\n          animation.callback(finished);\n        }\n      });\n    };\n\n    function sequence(animation, now) {\n      const currentAnim = animations[animation.animationIndex];\n      const finished = currentAnim.animation(currentAnim, now);\n      animation.current = currentAnim.current;\n      if (finished) {\n        // we want to call the callback after every single animation\n        if (currentAnim.callback) {\n          currentAnim.callback(true /* finished */);\n        }\n        currentAnim.finished = true;\n        animation.animationIndex += 1;\n        if (animation.animationIndex < animations.length) {\n          const nextAnim = animations[animation.animationIndex];\n          nextAnim.start(nextAnim, currentAnim.current, now, currentAnim);\n          return false;\n        }\n        return true;\n      }\n      return false;\n    }\n\n    function start(animation, value, now, previousAnimation) {\n      animation.animationIndex = 0;\n      firstAnimation.start(firstAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      animation: sequence,\n      start,\n      animationIndex: 0,\n      current: firstAnimation.current,\n      callback,\n    };\n  });\n}\n\nexport function repeat(\n  _nextAnimation,\n  numberOfReps = 2,\n  reverse = false,\n  callback\n) {\n  'worklet';\n  return defineAnimation(_nextAnimation, () => {\n    'worklet';\n\n    const nextAnimation =\n      typeof _nextAnimation === 'function' ? _nextAnimation() : _nextAnimation;\n\n    function repeat(animation, now) {\n      const finished = nextAnimation.animation(nextAnimation, now);\n      animation.current = nextAnimation.current;\n      if (finished) {\n        animation.reps += 1;\n        // call inner animation's callback on every repetition\n        // as the second argument the animation's current value is passed\n        if (nextAnimation.callback) {\n          nextAnimation.callback(true /* finished */, animation.current);\n        }\n        if (numberOfReps > 0 && animation.reps >= numberOfReps) {\n          return true;\n        }\n\n        const startValue = reverse\n          ? nextAnimation.current\n          : animation.startValue;\n        if (reverse) {\n          nextAnimation.toValue = animation.startValue;\n          animation.startValue = startValue;\n        }\n        nextAnimation.start(nextAnimation, startValue, now, nextAnimation);\n        return false;\n      }\n      return false;\n    }\n\n    const repCallback = (finished) => {\n      if (callback) {\n        callback(finished);\n      }\n      // when cancelled call inner animation's callback\n      if (!finished && nextAnimation.callback) {\n        nextAnimation.callback(false /* finished */);\n      }\n    };\n\n    function start(animation, value, now, previousAnimation) {\n      animation.startValue = value;\n      animation.reps = 0;\n      nextAnimation.start(nextAnimation, value, now, previousAnimation);\n    }\n\n    return {\n      animation: repeat,\n      start,\n      reps: 0,\n      current: nextAnimation.current,\n      callback: repCallback,\n    };\n  });\n}\n\n/* Deprecated, kept for backward compatibility. Will be removed soon */\nexport function loop(nextAnimation, numberOfLoops = 1) {\n  'worklet';\n  console.warn('Method `loop` is deprecated. Please use `repeat` instead');\n  return repeat(nextAnimation, Math.round(numberOfLoops * 2), true);\n}\n"]},"metadata":{},"sourceType":"script"}